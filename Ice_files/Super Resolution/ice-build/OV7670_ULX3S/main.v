// Code generated by Icestudio 0.12

`default_nettype none

//---- Top entity
module main (
 input v40f83b,
 input v58a987,
 input vd8f815,
 input v8a12b9,
 input va74953,
 input v5f84a6,
 input v2b4127,
 input v666f4e,
 input v244572,
 input [7:0] vef8052,
 output vb5062e,
 output [3:0] v814efa,
 output v094fae,
 output v74a75f,
 output vaa23fa,
 output vfca177,
 output [7:0] v115c4a,
 output v80d23e,
 output [12:0] v5dce43,
 output [15:0] vd005a1,
 output v7b1797,
 output vac2304,
 output v039554,
 output v22789a,
 output v7ff59b,
 output [1:0] v26f936,
 output [1:0] v9e17cc
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire [0:10] w10;
 wire [0:15] w11;
 wire w12;
 wire w13;
 wire w14;
 wire [0:15] w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire [0:7] w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire [0:7] w27;
 wire w28;
 wire w29;
 wire w30;
 wire w31;
 wire w32;
 wire w33;
 wire [0:12] w34;
 wire [0:1] w35;
 wire [0:1] w36;
 wire [0:15] w37;
 wire [0:3] w38;
 wire w39;
 assign w0 = v40f83b;
 assign w1 = v40f83b;
 assign w2 = v58a987;
 assign w3 = v58a987;
 assign w4 = v58a987;
 assign w5 = vd8f815;
 assign w6 = v8a12b9;
 assign w7 = va74953;
 assign w8 = v5f84a6;
 assign w13 = v40f83b;
 assign v7b1797 = w18;
 assign vac2304 = w19;
 assign v115c4a = w20;
 assign v039554 = w21;
 assign v22789a = w22;
 assign v7ff59b = w23;
 assign w24 = v2b4127;
 assign w25 = v666f4e;
 assign w26 = v244572;
 assign w27 = vef8052;
 assign vb5062e = w28;
 assign v094fae = w29;
 assign v74a75f = w30;
 assign vaa23fa = w31;
 assign vfca177 = w32;
 assign v80d23e = w33;
 assign v5dce43 = w34;
 assign v26f936 = w35;
 assign v9e17cc = w36;
 assign vd005a1 = w37;
 assign v814efa = w38;
 assign w1 = w0;
 assign w3 = w2;
 assign w4 = w2;
 assign w4 = w3;
 assign w13 = w0;
 assign w13 = w1;
 assign w39 = w12;
 vc187a2 v3383b1 (
  .v6a4126(w0),
  .vc57e23(w12)
 );
 v86cc32 vddf6dc (
  .v675708(w1),
  .v184dc1(w2),
  .v3f0c04(w5),
  .v9cc115(w6),
  .v5bf874(w7),
  .vbed5b3(w8),
  .v663e83(w9),
  .v694ba6(w10),
  .v6360eb(w11),
  .v744219(w18),
  .v3d8de7(w19),
  .vc26e9a(w20),
  .v92c601(w21),
  .vb229cc(w22),
  .vc308e6(w23),
  .v9ce3e7(w24),
  .vd89e9b(w25),
  .v8934f6(w26),
  .v7e1080(w27),
  .v5af38e(w39)
 );
 vcc582c v760717 (
  .v1f84c3(w3),
  .v826765(w9),
  .v3aa53b(w10),
  .ve24f15(w11),
  .vef4a17(w12),
  .v831e9c(w14),
  .v1417c5(w15),
  .v8284ba(w16),
  .v966dc3(w17),
  .vf84337(w28),
  .v8017c3(w29),
  .ve90166(w30),
  .v917e66(w31),
  .v7699e6(w32),
  .va88c3b(w33),
  .v2a425f(w34),
  .v4de55f(w35),
  .v140121(w36),
  .vce2330(w37)
 );
 v726f8b va95d99 (
  .vb72568(w4),
  .v06babe(w13),
  .v62a627(w14),
  .v43e567(w15),
  .v9cfd06(w16),
  .vce526d(w17),
  .v3dc608(w38)
 );
endmodule

//---------------------------------------------------
//-- asyn_fifo
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- fifo with different read/write clock domains
//---------------------------------------------------
//---- Top entity
module vc187a2 (
 input v6a4126,
 output vc57e23
);
 wire w0;
 wire w1;
 assign w0 = v6a4126;
 assign vc57e23 = w1;
 vc187a2_v32750d v32750d (
  .clkin(w0),
  .clkout0(w1)
 );
endmodule

//---------------------------------------------------
//-- pll_SDRAM
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Converts 25MHz input clk to 100MHz
//---------------------------------------------------

module vc187a2_v32750d (
 input clkin,
 output clkout0
);
 wire locked;
 
 (* FREQUENCY_PIN_CLKI="25" *)
 (* FREQUENCY_PIN_CLKOP="100" *)
 (* ICP_CURRENT="12" *) (* LPF_RESISTOR="8" *) (* MFG_ENABLE_FILTEROPAMP="1" *) (* MFG_GMCREF_SEL="2" *)
 EHXPLLL #(
         .PLLRST_ENA("DISABLED"),
         .INTFB_WAKE("DISABLED"),
         .STDBY_ENABLE("DISABLED"),
         .DPHASE_SOURCE("DISABLED"),
         .OUTDIVIDER_MUXA("DIVA"),
         .OUTDIVIDER_MUXB("DIVB"),
         .OUTDIVIDER_MUXC("DIVC"),
         .OUTDIVIDER_MUXD("DIVD"),
         .CLKI_DIV(1),
         .CLKOP_ENABLE("ENABLED"),
         .CLKOP_DIV(6),
         .CLKOP_CPHASE(2),
         .CLKOP_FPHASE(0),
         .FEEDBK_PATH("CLKOP"),
         .CLKFB_DIV(4)
     ) pll_i (
         .RST(1'b0),
         .STDBY(1'b0),
         .CLKI(clkin),
         .CLKOP(clkout0),
         .CLKFB(clkout0),
         .CLKINTFB(),
         .PHASESEL0(1'b0),
         .PHASESEL1(1'b0),
         .PHASEDIR(1'b1),
         .PHASESTEP(1'b1),
         .PHASELOADREG(1'b1),
         .PLLWAKESYNC(1'b0),
         .ENCLKOP(1'b0),
         .LOCK(locked)
 	);
 
 
endmodule
//---- Top entity
module v86cc32 #(
 parameter v15a1ce = "v15a1ce.list"
) (
 input v663e83,
 input v5af38e,
 input v184dc1,
 input v9ce3e7,
 input vd89e9b,
 input v8934f6,
 input [7:0] v7e1080,
 input v675708,
 input v3f0c04,
 input v9cc115,
 input v5bf874,
 input vbed5b3,
 output [10:0] v694ba6,
 output [15:0] v6360eb,
 output v744219,
 output v3d8de7,
 output [7:0] vc26e9a,
 output v92c601,
 output vb229cc,
 output vc308e6
);
 localparam p35 = v15a1ce;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire [0:7] w5;
 wire w6;
 wire w7;
 wire [0:7] w8;
 wire w9;
 wire w10;
 wire w11;
 wire [0:1] w12;
 wire [0:3] w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire w27;
 wire [0:15] w28;
 wire w29;
 wire w30;
 wire [0:7] w31;
 wire [0:10] w32;
 wire [0:15] w33;
 wire w34;
 wire w36;
 wire w37;
 wire w38;
 wire w39;
 assign w0 = v5af38e;
 assign w1 = v184dc1;
 assign w2 = v9ce3e7;
 assign w3 = vd89e9b;
 assign w4 = v8934f6;
 assign w5 = v7e1080;
 assign v744219 = w6;
 assign v3d8de7 = w7;
 assign vc26e9a = w8;
 assign w9 = v5af38e;
 assign w10 = v184dc1;
 assign vb229cc = w11;
 assign v92c601 = w14;
 assign w14 = v675708;
 assign vc308e6 = w15;
 assign w16 = v3f0c04;
 assign w17 = v9cc115;
 assign w18 = v5bf874;
 assign w19 = vbed5b3;
 assign w20 = v675708;
 assign w21 = v675708;
 assign w22 = v675708;
 assign w23 = v184dc1;
 assign w24 = v5af38e;
 assign w25 = v5af38e;
 assign w27 = v663e83;
 assign v694ba6 = w32;
 assign v6360eb = w33;
 assign w34 = v675708;
 assign w9 = w0;
 assign w10 = w1;
 assign w20 = w14;
 assign w21 = w14;
 assign w21 = w20;
 assign w22 = w14;
 assign w22 = w20;
 assign w22 = w21;
 assign w23 = w1;
 assign w23 = w10;
 assign w24 = w0;
 assign w24 = w9;
 assign w25 = w0;
 assign w25 = w9;
 assign w25 = w24;
 assign w34 = w14;
 assign w34 = w20;
 assign w34 = w21;
 assign w34 = w22;
 vcfd9ba vcda321 (
  .v6a82dd(w16),
  .v444878(w34),
  .vd4e5d7(w36)
 );
 vcfd9ba v09aef4 (
  .v6a82dd(w17),
  .v444878(w20),
  .vd4e5d7(w37)
 );
 vcfd9ba v7e24a5 (
  .v6a82dd(w18),
  .v444878(w21),
  .vd4e5d7(w38)
 );
 vcfd9ba vea3248 (
  .v6a82dd(w19),
  .v444878(w22),
  .vd4e5d7(w39)
 );
 v96ca63 v385830 (
  .v6ead63(w9),
  .vd0348a(w10),
  .vb03459(w11),
  .va203ef(w12),
  .v967217(w13),
  .v6a1f4c(w15),
  .v63e08d(w29),
  .ve9b86c(w30),
  .vc4be01(w31)
 );
 vd907ee vd1c30d (
  .v154578(w23),
  .vc312eb(w24),
  .v14fb5c(w25),
  .vbecff9(w26),
  .v88873d(w27),
  .vb730c2(w28),
  .vffb9ca(w32),
  .v947e96(w33)
 );
 v86cc32_v93ba14 #(
  .DATA(p35)
 ) v93ba14 (
  .clk_100(w0),
  .rst_n(w1),
  .cmos_pclk(w2),
  .cmos_href(w3),
  .cmos_vsync(w4),
  .cmos_db(w5),
  .cmos_rst_n(w6),
  .cmos_pwdn(w7),
  .led(w8),
  .ack(w12),
  .state(w13),
  .wr_en(w26),
  .pixel_q(w28),
  .start(w29),
  .stop(w30),
  .wr_data(w31),
  .key0(w36),
  .key1(w37),
  .key2(w38),
  .key3(w39)
 );
endmodule

//---------------------------------------------------
//-- camera_interface
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- communicates with OV7670 and set register configurations
//---------------------------------------------------

module v86cc32_v93ba14 #(
 parameter DATA = 0
) (
 input clk_100,
 input rst_n,
 input cmos_pclk,
 input cmos_href,
 input cmos_vsync,
 input [7:0] cmos_db,
 input [1:0] ack,
 input [3:0] state,
 input key0,
 input key1,
 input key2,
 input key3,
 output cmos_rst_n,
 output cmos_pwdn,
 output [7:0] led,
 output start,
 output stop,
 output [7:0] wr_data,
 output wr_en,
 output [15:0] pixel_q
);
 	 //FSM state declarations
 	 localparam idle=0,
 					start_sccb=1,
 					write_address=2,
 					write_data=3,
 					digest_loop=4,
 					delay=5,
 					vsync_fedge=6,
 					byte1=7,
 					byte2=8,
 					fifo_write=9,
 					stopping=10;
 					
 	 localparam wait_init=0,
 					sccb_idle=1,
 					sccb_address=2,
 					sccb_data=3,
 					sccb_stop=4;
 					
 	 localparam MSG_INDEX=77; //number of the last index to be digested by SCCB
 	 
 	 
 	 
 	 reg[3:0] state_q=0,state_d;
 	 reg[2:0] sccb_state_q=0,sccb_state_d;
 	 reg[7:0] addr_q,addr_d;
 	 reg[7:0] data_q,data_d;
 	 reg[7:0] brightness_q,brightness_d;
 	 reg[7:0] contrast_q,contrast_d;
 	 reg start,stop;
 	 reg[7:0] wr_data;
 	 reg[7:0] led_q=0,led_d; 
 	 reg[27:0] delay_q=0,delay_d;
 	 reg start_delay_q=0,start_delay_d;
 	 reg delay_finish;
 	 reg[20:0] message[250:0];
 	 reg[7:0] message_index_q=0,message_index_d;
 	 reg[15:0] pixel_q,pixel_d;
 	 reg wr_en;
 	 reg key0_tick,key1_tick,key2_tick,key3_tick;
 	 reg key0_prev,key1_prev,key2_prev,key3_prev;
 	 
 	 wire rd_tick;
 	 wire[7:0] rd_data;
 	 wire full;
 	 
 	 //buffer for all inputs coming from the camera
 	 reg pclk_1,pclk_2,href_1,href_2,vsync_1,vsync_2;
 	 
      initial begin  //read all register configuration values
         if(DATA) $readmemh(DATA,message);
      end
     
 	 
 	 //register operations
 	 always @(posedge clk_100,negedge rst_n) begin
 		if(!rst_n) begin
 			state_q<=0;
 			led_q<=0;
 			delay_q<=0;
 			start_delay_q<=0;
 			message_index_q<=0;
 			pixel_q<=0;
 			
 			sccb_state_q<=0;
 			addr_q<=0;
 			data_q<=0;
 			brightness_q<=0;
 			contrast_q<=0;
 		end
 		else begin
 			state_q<=state_d;
 			led_q<=led_d;
 			delay_q<=delay_d;
 			start_delay_q<=start_delay_d;
 			message_index_q<=message_index_d;			
 			pclk_1<=cmos_pclk; 
 			pclk_2<=pclk_1;
 			href_1<=cmos_href;
 			href_2<=href_1;
 			vsync_1<=cmos_vsync;
 			vsync_2<=vsync_1;
 			pixel_q<=pixel_d;
 			
 			sccb_state_q<=sccb_state_d;
 			addr_q<=addr_d;
 			data_q<=data_d;
 			brightness_q<=brightness_d;
 			contrast_q<=contrast_d;
 		end
 	 end
 	 	 
 	 
 	 //FSM next-state logics
 	 always @* begin
 		state_d=state_q;
 		led_d=led_q;
 		start=0;
 		stop=0;
 		wr_data=0;
 		start_delay_d=start_delay_q;
 		delay_d=delay_q;
 		delay_finish=0;
 		message_index_d=message_index_q;
 		pixel_d=pixel_q;
 		wr_en=0;
 		
 		sccb_state_d=sccb_state_q;
 		addr_d=addr_q;
 		data_d=data_q;
 		brightness_d=brightness_q;
 		contrast_d=contrast_q;
 		
 		//delay logic  
 		if(start_delay_q) delay_d=delay_q+1'b1;
 		if(delay_q[16] && message_index_q!=(MSG_INDEX+1) && (state_q!=start_sccb))  begin  //delay between SCCB transmissions (0.66ms)
 			delay_finish=1;
 			start_delay_d=0;
 			delay_d=0;
 		end
 		else if((delay_q[26] && message_index_q==(MSG_INDEX+1)) || (delay_q[26] && state_q==start_sccb)) begin //delay BEFORE SCCB transmission, AFTER SCCB transmission, and BEFORE retrieving pixel data from camera (0.67s)
 			delay_finish=1;
 			start_delay_d=0;
 			delay_d=0;
 		end
 		
 		case(state_q) 
 		
 					////////Begin: Setting register values of the camera via SCCB///////////
 					
 			  idle:  if(delay_finish) begin //idle for 0.6s to start-up the camera
 							state_d=start_sccb; 
 							start_delay_d=0;
 						end
 						else start_delay_d=1;
 
 		start_sccb:  begin   //start of SCCB transmission
 							start=1;
 							wr_data=8'h42; //slave address of OV7670 for write
 							state_d=write_address;	
 						end
 	 write_address: if(ack==2'b11) begin 
 							wr_data=message[message_index_q][15:8]; //write address
 							state_d=write_data;
 						end
 		 write_data: if(ack==2'b11) begin 
 							wr_data=message[message_index_q][7:0]; //write data
 							state_d=digest_loop;
 						end
 	  digest_loop: if(ack==2'b11) begin //stop sccb transmission
 							stop=1;
 							start_delay_d=1;
 							message_index_d=message_index_q+1'b1;
 							state_d=delay;
 						end
 			  delay: begin
 							if(message_index_q==(MSG_INDEX+1) && delay_finish) begin 
 								state_d=vsync_fedge; //if all messages are already digested, proceed to retrieving camera pixel data
 								led_d=8'b0011_0011; //red LEDs
 							end
 							else if(state==0 && delay_finish) state_d=start_sccb; //small delay before next SCCB transmission(if all messages are not yet digested)
 						end
 			  
 			  
 
 				///////////////Begin: Retrieving Pixel Data from Camera to be Stored to SDRAM/////////////////
 				
 		vsync_fedge: if(vsync_1==0 && vsync_2==1) state_d=byte1; //vsync falling edge means new frame is incoming
 				byte1: if(pclk_1==1 && pclk_2==0 && href_1==1 && href_2==1) begin //rising edge of pclk means new pixel data(first byte of 16-bit pixel RGB565) is available at output
 								pixel_d[15:8]=cmos_db;
 								state_d=byte2;
 						 end
 						 else if(vsync_1==1 && vsync_2==1) begin
 							state_d=vsync_fedge;
 						 end
 				byte2: if(pclk_1==1 && pclk_2==0 && href_1==1 && href_2==1) begin //rising edge of pclk means new pixel data(second byte of 16-bit pixel RGB565) is available at output
 								pixel_d[7:0]=cmos_db;
 								state_d=fifo_write;
 						 end
 						 else if(vsync_1==1 && vsync_2==1) begin
 							state_d=vsync_fedge;
 						 end
 		 fifo_write: begin //write the 16-bit data to asynchronous fifo to be retrieved later by SDRAM
 								wr_en=1;
 								state_d=byte1;
 								led_d=8'b1100_1100; //debugging led
 						 end
 		default: state_d=idle;
 		endcase
 		
 		//Logic for increasing/decreasing brightness and contrast via the 4 keybuttons
 		case(sccb_state_q)
 			wait_init: if(state_q==byte1) begin //wait for initial SCCB transmission to finish
 							sccb_state_d=sccb_idle;
 							addr_d=0;
 							data_d=0;
 							brightness_d=8'h00; 
 							contrast_d=8'h40;
 						  end
 			sccb_idle: if(state==0) begin //wait for any pushbutton
 								if(key0_tick) begin//increase brightness
 									brightness_d=(brightness_q[7]==1)? brightness_q-5:brightness_q+5;
 									if(brightness_q==8'h80) brightness_d=0;
 									start=1;
 									wr_data=8'h42; //slave address of OV7670 for write
 									addr_d=8'h55; //brightness control address
 									data_d=brightness_d;
 									sccb_state_d=sccb_address;
 									led_d=0;
 								end
 								if(key1_tick) begin //decrease brightness
 									brightness_d=(brightness_q[7]==1)? brightness_q+5:brightness_q-5;
 									if(brightness_q==0) brightness_d=8'h80;
 									start=1;
 									wr_data=8'h42; 
 									addr_d=8'h55;
 									data_d=brightness_d;
 									sccb_state_d=sccb_address;
 									led_d=0;
 								end
 								else if(key2_tick) begin //increase contrast
 									contrast_d=contrast_q+5;
 									start=1;
 									wr_data=8'h42; //slave address of OV7670 for write
 									addr_d=8'h56; //contrast control address
 									data_d=contrast_d;
 									sccb_state_d=sccb_address;
 									led_d=0;
 								end
 								else if(key3_tick) begin //change contrast
 									contrast_d=contrast_q-5;
 									start=1;
 									wr_data=8'h42;
 									addr_d=8'h56;
 									data_d=contrast_d;
 									sccb_state_d=sccb_address;
 									led_d=0;
 								end
 						  end
 		sccb_address: if(ack==2'b11) begin 
 							wr_data=addr_q; //write address
 							sccb_state_d=sccb_data;
 						end
 		  sccb_data: if(ack==2'b11) begin 
 							wr_data=data_q; //write databyte
 							sccb_state_d=sccb_stop;
 						 end
 		  sccb_stop: if(ack==2'b11) begin //stop
 							stop=1;
 							sccb_state_d=sccb_idle;
 							led_d=4'b1001;
 						 end
 			 default: sccb_state_d=wait_init;
 		endcase
 		
 	 end
 	 
 
 	 assign cmos_pwdn=0; //fixed at ground
 	 assign cmos_rst_n=1; //fixed at high
 	 
 	 assign led=led_q; //debugging LED , non-red LED if no problem
 	 
 	 always @(posedge clk_100) begin
     	 key0_prev<=key0;
     	 key1_prev<=key1;
     	 key2_prev<=key2;
     	 key3_prev<=key3;
     	 
     	 key0_tick=!key0_prev && key0;
     	 key1_tick=!key1_prev && key1;
     	 key2_tick=!key2_prev && key2;
     	 key3_tick=!key3_prev && key3;
 	 end
 	 
endmodule
//---- Top entity
module vcfd9ba (
 input v444878,
 input v6a82dd,
 output vd4e5d7
);
 wire w0;
 wire w1;
 wire w2;
 assign vd4e5d7 = w0;
 assign w1 = v444878;
 assign w2 = v6a82dd;
 vcfd9ba_va7041c va7041c (
  .out(w0),
  .clk(w1),
  .in(w2)
 );
endmodule

//---------------------------------------------------
//-- Debouncer
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Remove the rebound on a mechanical switch
//---------------------------------------------------

module vcfd9ba_va7041c (
 input clk,
 input in,
 output out
);
 //-- Debouncer Circuit
 //-- It produces a stable output when the
 //-- input signal is bouncing
 
 reg btn_prev = 0;
 reg btn_out_r = 0;
 
 reg [16:0] counter = 0;
 
 
 always @(posedge clk) begin
 
   //-- If btn_prev and btn_in are differents
   if (btn_prev ^ in == 1'b1) begin
     
       //-- Reset the counter
       counter <= 0;
       
       //-- Capture the button status
       btn_prev <= in;
   end
     
   //-- If no timeout, increase the counter
   else if (counter[16] == 1'b0)
       counter <= counter + 1;
       
   else
     //-- Set the output to the stable value
     btn_out_r <= btn_prev;
 
 end
 
 assign out = btn_out_r;
 
endmodule
//---- Top entity
module v96ca63 #(
 parameter vfa830d = 100000000,
 parameter v882d22 = 100000,
 parameter v64365f = 2
) (
 input v6ead63,
 input vd0348a,
 input v63e08d,
 input ve9b86c,
 input [7:0] vc4be01,
 output v204c37,
 output [1:0] va203ef,
 output [7:0] v401ec0,
 output [3:0] v967217,
 output vb03459,
 output v6a1f4c
);
 localparam p10 = vfa830d;
 localparam p11 = v882d22;
 localparam p12 = v64365f;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:7] w4;
 wire w5;
 wire [0:3] w6;
 wire [0:7] w7;
 wire [0:1] w8;
 wire w9;
 wire w13;
 assign w0 = v6ead63;
 assign w1 = vd0348a;
 assign w2 = v63e08d;
 assign w3 = ve9b86c;
 assign w4 = vc4be01;
 assign v204c37 = w5;
 assign v967217 = w6;
 assign v401ec0 = w7;
 assign va203ef = w8;
 assign vb03459 = w9;
 assign v6a1f4c = w13;
 v96ca63_vb70907 #(
  .main_clock(p10),
  .freq(p11),
  .addr_bytes(p12)
 ) vb70907 (
  .clk(w0),
  .rst_n(w1),
  .start(w2),
  .stop(w3),
  .wr_data(w4),
  .rd_tick(w5),
  .state(w6),
  .rd_data(w7),
  .ack(w8),
  .scl(w9),
  .sda(w13)
 );
endmodule

//---------------------------------------------------
//-- i2c
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- i2c for camera configuration
//---------------------------------------------------

module v96ca63_vb70907 #(
 parameter main_clock = 0,
 parameter freq = 0,
 parameter addr_bytes = 0
) (
 input clk,
 input rst_n,
 input start,
 input stop,
 input [7:0] wr_data,
 output rd_tick,
 output [1:0] ack,
 output [7:0] rd_data,
 output [3:0] state,
 output scl,
 output sda
);
 	 localparam full= (main_clock)/(2*freq),
 					half= full/2,
 					counter_width=log2(full);
 					
 	 function integer log2(input integer n); //automatically determines the width needed by counter
 		integer i;
 		 begin
 			log2=1;
 			for(i=0;2**i<n;i=i+1)
 				log2=i+1;
 		 end
 	 endfunction
 		 
 	 //FSM state declarations
 	 localparam[3:0] 		idle=0,
 							starting=1,
 							packet=2,
 							ack_servant=3,
 							read=4,
 							ack_master=5,
 							stop_1=6,
 							stop_2=7;
 	 reg[3:0] state_q=idle,state_d;
 	 reg op_q=0,op_d;
 	 reg[3:0] idx_q=0,idx_d;
 	 reg[8:0] wr_data_q=0,wr_data_d;
 	 reg[7:0] rd_data_q,rd_data_d;
 	 reg scl_q=0,scl_d;
 	 reg sda_q=0,sda_d;
 	 reg[counter_width-1:0] counter_q=0,counter_d;
 	 reg[1:0] addr_bytes_q=0,addr_bytes_d;
 	 wire scl_lo,scl_hi;
 	 wire sda_in;
 	 reg rd_tick;
 	 reg[1:0] ack;
 	//register operations
 	 always@(posedge clk, negedge rst_n) begin
 		if(!rst_n) begin
 			state_q<=idle;
 			idx_q<=0;
 			wr_data_q<=0;
 			scl_q<=0;
 			sda_q<=0;
 			counter_q<=0;
 			rd_data_q<=0;
 			addr_bytes_q<=0;
 		end
 		else begin
 			state_q<=state_d;
 			op_q<=op_d;
 			idx_q<=idx_d;
 			wr_data_q<=wr_data_d;
 			scl_q<=scl_d;
 			sda_q<=sda_d;
 			counter_q<=counter_d;
 			rd_data_q<=rd_data_d;
 			addr_bytes_q<=addr_bytes_d;
 		end
 	 end
 	 
 	 
 	 //free-running clk, freq depends on parameter "freq"
 	 always @* begin
 		counter_d=counter_q+1;
 		scl_d=scl_q;
 		if(state_q==idle || state_q==starting) scl_d=1'b1;
 		else if(counter_q==full) begin
 			counter_d=0;
 			scl_d=(scl_q==0)?1'b1:1'b0;
 		end
 	 end
 	 
 	 
 	 //FSM next-state logic
 	 always @* begin
 		state_d=state_q;
 		op_d=op_q;
 		idx_d=idx_q;
 		wr_data_d=wr_data_q;
 		rd_data_d=rd_data_q;
 		addr_bytes_d=addr_bytes_q;
 		sda_d=sda_q;
 		ack=0;
 		rd_tick=0;
 		
 		case(state_q)
 					idle: begin		//wait for the "start" to assert
 								sda_d=1'b1;
 								addr_bytes_d=addr_bytes; 
 								if(start==1'b1) begin
 									wr_data_d={wr_data,1'b1}; //the last 1'b1 is for the ACK coming from the servant("1" means high impedance or "reading")
 									op_d= (wr_data[0])? 1:0; // if last bit(R/W bit) is one:read operation, else write operation
 									idx_d=8; //index to be used on transmitting the wr_data serially(MSB first)
 									state_d=starting;
 								end
 							 end
 							 
 				starting: if(scl_hi) begin //start command, change sda to low while scl is high
 								sda_d=0;
 								state_d=packet;
 							 end
 							 
 				  packet: if(scl_lo) begin //transmit wr_data serially(MSB first)
 								sda_d= (wr_data_q[idx_q]==0)? 0:1'b1;
 								idx_d= idx_q-1;
 								if(idx_q==0) begin
 									state_d=ack_servant;
 									idx_d=0;
 								end
 							 end
   							 
 			ack_servant: if(scl_hi) begin //wait for ACK bit response(9th bit) from servant
 								ack[1]=1;
 								ack[0]=!sda_in; 
 								wr_data_d={wr_data,1'b1}; //after acknowledge tick, master must have already have the next data it wants to give
 								addr_bytes_d=addr_bytes_q-1;
 								if(stop) state_d=stop_1; //master can forcefully stops the transaction(even if response is either NACK or ACK)
 								else if(op_q && addr_bytes_q==0) begin //start reading after writing addr_bytes of packets for address
 									idx_d=7;
 									state_d=read;
 								end
 								else begin //write next packet
 									idx_d=8;
 									state_d=packet; 
 								end
 							 end
 							 
 					 read: if(scl_hi) begin //read data from slave(MSB first)
 								rd_data_d[idx_q]=sda_in;
 								idx_d=idx_q-1;
 								if(idx_q==0) state_d=ack_master;
 							 end
 							 
 			 ack_master: if(scl_lo) begin //master must ACK after receiving data from servant
 								sda_d=1'b0; 
 								if(sda_q==0) begin //one whole bit(two scl_lo) had passed
 									rd_tick=1;
 									idx_d=7;
 									if(stop) state_d=stop_1; //after receiving data, master can opt to stop
 									else state_d=read; ///after receiving data, master can also just continue receving more data
 								end
 							 end
 				  stop_1: if(scl_lo) begin
 								sda_d=1'b0;
 								state_d=stop_2;
 							 end
 				  stop_2: if(scl_hi) begin
 								sda_d=1'b1;
 								state_d=idle;
 							 end
 				 default: state_d=idle;
 		endcase
 	 end
 	 
 	 /*
 	 //i2c output logic
 	 assign scl=scl_q? 1'bz:0; //bidiectional logic for pull-up scl
 	 assign sda=sda_q? 1'bz:0; //bidirectional logic for pull-up scl
 	 assign sda_in=sda;
 	 */
 	 
 	 //sccb output logic
 	 wire temp;
 	 assign scl=scl_q; //sccb scl does not need pull-up
 	 assign temp=(state_q==read || state_q==ack_servant);
 	 //assign sda=(state_q==read || state_q==ack_servant)? 1'bz : sda_q; //sccb sda does not need pull-up
 	 //assign sda_in=sda;
 	 
 	 TRELLIS_IO #(.DIR("BIDIR")) tristate	 (
 	  .B(sda),
 	  .I(sda_q),
 	  .T(temp),
 	  .O(sda_in)
 	 );
 	 
 	 assign scl_hi= scl_q==1'b1 && counter_q==half && scl==1'b1; //scl is on the middle of a high(1) bit
 	 assign scl_lo= scl_q==1'b0 && counter_q==half; //scl is on the middle of a low(0) bit
 	 assign rd_data=rd_data_q;
 	 assign state=state_q;
endmodule
//---- Top entity
module vd907ee (
 input v154578,
 input vc312eb,
 input v14fb5c,
 input vbecff9,
 input v88873d,
 input [15:0] vb730c2,
 output v9fff91,
 output v01607e,
 output [10:0] v8ceb21,
 output [10:0] vffb9ca,
 output [15:0] v947e96
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire [0:10] w10;
 wire [0:10] w11;
 wire [0:10] w12;
 wire [0:10] w13;
 wire [0:15] w14;
 wire [0:15] w15;
 assign w1 = v154578;
 assign w2 = vc312eb;
 assign w3 = v14fb5c;
 assign w4 = vbecff9;
 assign w5 = v88873d;
 assign w6 = vc312eb;
 assign w7 = v14fb5c;
 assign v9fff91 = w8;
 assign v01607e = w9;
 assign v8ceb21 = w10;
 assign vffb9ca = w11;
 assign w14 = vb730c2;
 assign v947e96 = w15;
 assign w6 = w2;
 assign w7 = w3;
 vd907ee_v65c4d4 v65c4d4 (
  .we(w0),
  .rst_n(w1),
  .clk_write(w2),
  .clk_read(w3),
  .write(w4),
  .read(w5),
  .full(w8),
  .empty(w9),
  .data_count_w(w10),
  .data_count_r(w11),
  .w_ptr(w12),
  .r_ptr(w13)
 );
 v1d9258 vebffa0 (
  .va43ab9(w0),
  .ve163d2(w6),
  .vf6ac69(w7),
  .v6d0616(w12),
  .v79bd3e(w13),
  .v63ce58(w14),
  .v63f4ed(w15)
 );
endmodule

//---------------------------------------------------
//-- asyn_fifo
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- fifo with different read/write clock domains
//---------------------------------------------------

module vd907ee_v65c4d4 (
 input rst_n,
 input clk_write,
 input clk_read,
 input write,
 input read,
 output full,
 output empty,
 output [10:0] data_count_w,
 output [10:0] data_count_r,
 output we,
 output [10:0] w_ptr,
 output [10:0] r_ptr
);
  	 localparam DATA_WIDTH=16,
 	            FIFO_DEPTH_WIDTH=11,
 	            FIFO_DEPTH=2**FIFO_DEPTH_WIDTH;
 	 
 	 initial begin
 		full=0;
 		empty=1;
 	 end
 	 
 	 reg full, empty;
 	 reg[10:0] data_count_r,data_count_w;
 	 
 	 ///////////////////WRITE CLOCK DOMAIN//////////////////////////////
 	 reg[FIFO_DEPTH_WIDTH:0] w_ptr_q=0; //binary counter for write pointer
 	 reg[FIFO_DEPTH_WIDTH:0] r_ptr_sync; //binary pointer for read pointer sync to write clk
 	 wire[FIFO_DEPTH_WIDTH:0] w_grey,w_grey_nxt; //grey counter for write pointer
 	 reg[FIFO_DEPTH_WIDTH:0] r_grey_sync; //grey counter for the read pointer synchronized to write clock
 	 
 	 reg[3:0] i; //log_2(FIFO_DEPTH_WIDTH)
 	 
 	 assign w_grey=w_ptr_q^(w_ptr_q>>1); //binary to grey code conversion for current write pointer
 	 assign w_grey_nxt=(w_ptr_q+1'b1)^((w_ptr_q+1'b1)>>1);  //next grey code
 	 assign we= write && !full; 
 	 
 	 //register operation
 	 always @(posedge clk_write,negedge rst_n) begin
 		if(!rst_n) begin
 			w_ptr_q<=0;
 			full<=0;
 		end
 		else begin
 			if(write && !full) begin //write condition
 				w_ptr_q<=w_ptr_q+1'b1; 
 				full <= w_grey_nxt == {~r_grey_sync[FIFO_DEPTH_WIDTH:FIFO_DEPTH_WIDTH-1],r_grey_sync[FIFO_DEPTH_WIDTH-2:0]}; //algorithm for full logic which can be observed on the grey code table
 			end
 			else full <= w_grey == {~r_grey_sync[FIFO_DEPTH_WIDTH:FIFO_DEPTH_WIDTH-1],r_grey_sync[FIFO_DEPTH_WIDTH-2:0]}; 
 			
 			for(i=0;i<=FIFO_DEPTH_WIDTH;i=i+1) r_ptr_sync[i]=^(r_grey_sync>>i); //grey code to binary converter 
 			data_count_w <= (w_ptr_q>=r_ptr_sync)? (w_ptr_q-r_ptr_sync):(FIFO_DEPTH-r_ptr_sync+w_ptr_q); //compares write pointer and sync read pointer to generate data_count
 		end							
 	 end
 
 	/////////////////////////////////////////////////////////////////////
 	 
 	 
 	  ///////////////////READ CLOCK DOMAIN//////////////////////////////
 	 reg[FIFO_DEPTH_WIDTH:0] r_ptr_q=0; //binary counter for read pointer
 	 wire[FIFO_DEPTH_WIDTH:0] r_ptr_d;
 	 reg[FIFO_DEPTH_WIDTH:0] w_ptr_sync; //binary counter for write pointer sync to read clk
 	 reg[FIFO_DEPTH_WIDTH:0] w_grey_sync; //grey counter for the write pointer synchronized to read clock
 	 wire[FIFO_DEPTH_WIDTH:0] r_grey,r_grey_nxt; //grey counter for read pointer 
 	 
 	 
 	 assign r_grey= r_ptr_q^(r_ptr_q>>1);  //binary to grey code conversion
 	 assign r_grey_nxt= (r_ptr_q+1'b1)^((r_ptr_q+1'b1)>>1); //next grey code
 	 assign r_ptr_d= (read && !empty)? r_ptr_q+1'b1:r_ptr_q;
 	 
 	 //register operation
 	 always @(posedge clk_read,negedge rst_n) begin
 		if(!rst_n) begin
 			r_ptr_q<=0;
 			empty<=1;
 		end
 		else begin
 			r_ptr_q<=r_ptr_d;
 			if(read && !empty) empty <= r_grey_nxt==w_grey_sync;//empty condition
 			else empty <= r_grey==w_grey_sync; 
 			
 			for(i=0;i<=FIFO_DEPTH_WIDTH;i=i+1) w_ptr_sync[i]=^(w_grey_sync>>i); //grey code to binary converter
 			data_count_r = (w_ptr_q>=r_ptr_sync)? (w_ptr_q-r_ptr_sync):(FIFO_DEPTH-r_ptr_sync+w_ptr_q); //compares read pointer to sync write pointer to generate data_count
 		end
 	 end
 	 ////////////////////////////////////////////////////////////////////////
 	 
 	 
 	 /////////////////////CLOCK DOMAIN CROSSING//////////////////////////////
 	 reg[FIFO_DEPTH_WIDTH:0] r_grey_sync_temp;
 	 reg[FIFO_DEPTH_WIDTH:0] w_grey_sync_temp;
 	 always @(posedge clk_write) begin //2 D-Flipflops for reduced metastability in clock domain crossing from READ DOMAIN to WRITE DOMAIN
 		r_grey_sync_temp<=r_grey; 
 		r_grey_sync<=r_grey_sync_temp;
 	 end
 	 always @(posedge clk_read) begin //2 D-Flipflops for reduced metastability in clock domain crossing from WRITE DOMAIN to READ DOMAIN
 		w_grey_sync_temp<=w_grey;
 		w_grey_sync<=w_grey_sync_temp;
 	 end
 	 
 	//////////////////////////////////////////////////////////////////////////
 	
 	assign w_ptr=w_ptr_q[10:0];
 	assign r_ptr=r_ptr_d[10:0];
 	 
 	 
 	 
endmodule
//---- Top entity
module v1d9258 (
 input vf6ac69,
 input ve163d2,
 input va43ab9,
 input [15:0] v63ce58,
 input [10:0] v6d0616,
 input [10:0] v79bd3e,
 output [15:0] v63f4ed
);
 wire w0;
 wire w1;
 wire w2;
 wire [0:10] w3;
 wire [0:10] w4;
 wire [0:15] w5;
 wire [0:15] w6;
 assign w0 = vf6ac69;
 assign w1 = ve163d2;
 assign w2 = va43ab9;
 assign w3 = v6d0616;
 assign w4 = v79bd3e;
 assign w5 = v63ce58;
 assign v63f4ed = w6;
 v1d9258_v21516f v21516f (
  .clk_r(w0),
  .clk_w(w1),
  .we(w2),
  .addr_a(w3),
  .addr_b(w4),
  .din(w5),
  .dout(w6)
 );
endmodule

//---------------------------------------------------
//-- dual_port_ram
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- uses block ram with separate read/write clock
//---------------------------------------------------

module v1d9258_v21516f (
 input clk_r,
 input clk_w,
 input we,
 input [15:0] din,
 input [10:0] addr_a,
 input [10:0] addr_b,
 output [15:0] dout
);
 	localparam ADDR_WIDTH=11,
 	               DATA_WIDTH=16;
 	
 	reg[DATA_WIDTH-1:0] ram[2**ADDR_WIDTH-1:0];
 	reg[ADDR_WIDTH-1:0] addr_b_q;
 	
 	always @(posedge clk_w) begin
 		if(we) ram[addr_a]<=din;
 	end
 	always @(posedge clk_r) begin
 		addr_b_q<=addr_b;	
 	end
 	assign dout=ram[addr_b_q];
endmodule
//---- Top entity
module vcc582c (
 input vef4a17,
 input v1f84c3,
 input [10:0] v3aa53b,
 input [15:0] ve24f15,
 input v8284ba,
 input v966dc3,
 output v826765,
 output vf84337,
 output v8017c3,
 output ve90166,
 output v917e66,
 output v7699e6,
 output va88c3b,
 output [12:0] v2a425f,
 output [1:0] v4de55f,
 output [1:0] v140121,
 output [15:0] vce2330,
 output v831e9c,
 output [15:0] v1417c5
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:14] w4;
 wire [0:15] w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire [0:15] w10;
 wire [0:15] w11;
 wire w12;
 wire [0:10] w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire [0:1] w25;
 wire [0:15] w26;
 wire [0:1] w27;
 wire [0:10] w28;
 wire [0:12] w29;
 wire w30;
 assign w0 = vef4a17;
 assign w1 = v1f84c3;
 assign w2 = vef4a17;
 assign w3 = v1f84c3;
 assign w5 = ve24f15;
 assign w6 = v1f84c3;
 assign w7 = v8284ba;
 assign w8 = vef4a17;
 assign v1417c5 = w11;
 assign v831e9c = w12;
 assign v826765 = w16;
 assign w18 = v966dc3;
 assign vf84337 = w19;
 assign v8017c3 = w20;
 assign ve90166 = w21;
 assign v917e66 = w22;
 assign v7699e6 = w23;
 assign va88c3b = w24;
 assign v4de55f = w25;
 assign vce2330 = w26;
 assign v140121 = w27;
 assign w28 = v3aa53b;
 assign v2a425f = w29;
 assign w2 = w0;
 assign w3 = w1;
 assign w6 = w1;
 assign w6 = w3;
 assign w8 = w0;
 assign w8 = w2;
 vcc582c_vd61c04 vd61c04 (
  .clk(w0),
  .rst_n(w1),
  .f_addr(w4),
  .data_count_w(w13),
  .f2s_data_valid(w14),
  .rw(w15),
  .rd_camera(w16),
  .ready(w17),
  .data_count_camera_fifo(w28),
  .rw_en(w30)
 );
 v7654a2 ve26fd1 (
  .vbe24c9(w2),
  .vdf2bc1(w3),
  .v9669f7(w4),
  .v8a3550(w5),
  .vbf18cc(w9),
  .v742eac(w10),
  .v4d9a75(w14),
  .v4c636b(w15),
  .vde3dc9(w17),
  .v1d370a(w19),
  .v6fa753(w20),
  .va889a6(w21),
  .vb4e6e9(w22),
  .v802779(w23),
  .v6c0920(w24),
  .v7a23d0(w25),
  .veb4698(w26),
  .v8e5ad1(w27),
  .va4660d(w29),
  .vc7b821(w30)
 );
 vd907ee vb01cee (
  .v154578(w6),
  .v14fb5c(w7),
  .vc312eb(w8),
  .vbecff9(w9),
  .vb730c2(w10),
  .v947e96(w11),
  .v01607e(w12),
  .v8ceb21(w13),
  .v88873d(w18)
 );
endmodule

//---------------------------------------------------
//-- sdram_interface
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- stores pixel data from camera then send data to HDMI
//---------------------------------------------------

module vcc582c_vd61c04 (
 input clk,
 input rst_n,
 input [10:0] data_count_camera_fifo,
 input f2s_data_valid,
 input [10:0] data_count_w,
 input ready,
 output rd_camera,
 output rw,
 output rw_en,
 output [14:0] f_addr
);
 	 //FSM state declarations
 	 localparam idle=0,
 					burst_op=1;
 					
 	 reg state_q=0,state_d;	 
 	 reg[14:0] colored_addr_q=0,colored_addr_d;
 	 reg[14:0] rd_addr_q=0,rd_addr_d;
 	 reg rw,rw_en;
 	 reg orig_q,orig_d;
 	 reg[14:0] f_addr;
 	 wire[15:0] s2f_data;
 	 wire s2f_data_valid;
 	 wire ready;
 	 wire[7:0] data_fifo;
 	 wire[9:0] fifo_data_count;
 	 wire[15:0] f2s_data;
 	 wire[9:0] data_count_r;
 	 
 	 //register operation
 	 always @(posedge clk,negedge rst_n) begin
 		if(!rst_n) begin
 			state_q<=0;
 			colored_addr_q<=0;
 			rd_addr_q<=0;
 			orig_q<=0;
 		end
 		else begin
 			state_q<=state_d;
 			colored_addr_q<=colored_addr_d;
 			rd_addr_q<=rd_addr_d;
 			orig_q<=orig_d;
 		end
 	 end
 	 
 	 //FSM next-state declarations
 	 always @* begin
 		state_d=state_q;
 		colored_addr_d=colored_addr_q;
 		rd_addr_d=rd_addr_q;
 		f_addr=0;
 		rw=0;
 		rw_en=0;
 		orig_d=orig_q;
 		
 		case(state_q)
 			    idle: if(data_count_camera_fifo>512 && ready) begin //wait for the first 512 pixel-data to fill the asyn_fifo then burst-write it to sdram
 							rw_en=1;
 							rw=0;
 							colored_addr_d=1;
 							f_addr=colored_addr_q;
 							state_d=burst_op;
 							orig_d=1;
 						 end
 			burst_op: if(ready) begin //choose whether to read the colored image or edge detected image OR write to the fifo of VGA
 								if(data_count_camera_fifo>512) begin //colored image container is filled to 512 thus we can now burst-write(full-page has 512 data) it to SDRAM 
 									rw_en=1;
 									rw=0;
 									colored_addr_d=(colored_addr_q==599)? 0:colored_addr_q+1'b1; //One frame(640x480) fills the addresses 0-to-599
 									f_addr=colored_addr_q;
 									orig_d=1;
 								end
 								
 								else if(data_count_w<250) begin //asyn_fifo of VGA has only 250 pixel data left, we will now fill it by another 512 pixel data via burst reading the sdram
 									rw_en=1;
 									rw=1;
 									rd_addr_d=(rd_addr_q==599)? 0:rd_addr_q+1'b1;
 									f_addr= rd_addr_q;
 								end
 						 end
 			 default: state_d=idle;
 		endcase
 	 end
 	
 	 assign rd_camera= f2s_data_valid && orig_d;
 	 
endmodule
//---- Top entity
module v7654a2 (
 input vbe24c9,
 input vdf2bc1,
 input v4c636b,
 input vc7b821,
 input [14:0] v9669f7,
 input [15:0] v8a3550,
 output [15:0] v742eac,
 output vbf18cc,
 output v4d9a75,
 output vde3dc9,
 output v1d370a,
 output v6fa753,
 output va889a6,
 output vb4e6e9,
 output v802779,
 output v6c0920,
 output [12:0] va4660d,
 output [1:0] v7a23d0,
 output [1:0] v8e5ad1,
 output [15:0] veb4698
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:14] w4;
 wire [0:15] w5;
 wire [0:15] w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire [0:12] w16;
 wire [0:1] w17;
 wire [0:15] w18;
 wire [0:1] w19;
 assign w0 = vdf2bc1;
 assign w1 = vbe24c9;
 assign w2 = v4c636b;
 assign w3 = vc7b821;
 assign w4 = v9669f7;
 assign w5 = v8a3550;
 assign v742eac = w6;
 assign vbf18cc = w7;
 assign v4d9a75 = w8;
 assign vde3dc9 = w9;
 assign v1d370a = w10;
 assign v6fa753 = w11;
 assign va889a6 = w12;
 assign vb4e6e9 = w13;
 assign v802779 = w14;
 assign v6c0920 = w15;
 assign va4660d = w16;
 assign v7a23d0 = w17;
 assign veb4698 = w18;
 assign v8e5ad1 = w19;
 v7654a2_vf775c2 vf775c2 (
  .rst_n(w0),
  .clk(w1),
  .rw(w2),
  .rw_en(w3),
  .f_addr(w4),
  .f2s_data(w5),
  .s2f_data(w6),
  .s2f_data_valid(w7),
  .f2s_data_valid(w8),
  .ready(w9),
  .s_clk(w10),
  .s_cke(w11),
  .s_cs_n(w12),
  .s_ras_n(w13),
  .s_cas_n(w14),
  .s_we_n(w15),
  .s_addr(w16),
  .s_ba(w17),
  .s_dq(w18),
  .s_dqm(w19)
 );
endmodule

//---------------------------------------------------
//-- sdram,_controller
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- SDRAM single-data rate controller 
//---------------------------------------------------

module v7654a2_vf775c2 (
 input clk,
 input rst_n,
 input rw,
 input rw_en,
 input [14:0] f_addr,
 input [15:0] f2s_data,
 output [15:0] s2f_data,
 output s2f_data_valid,
 output f2s_data_valid,
 output ready,
 output s_clk,
 output s_cke,
 output s_cs_n,
 output s_ras_n,
 output s_cas_n,
 output s_we_n,
 output [12:0] s_addr,
 output [1:0] s_ba,
 output [1:0] s_dqm,
 output [15:0] s_dq
);
 	 //s_clock(clk input to sdram) is 180 degrees lagging from main clock to solve the hold-setup time requirements of sdram
 	 ODDRX1F oddr_primitive
 	 (
 		.D0(1'b0), //1'b0
 		.D1(1'b1), //1'b1
 		.SCLK(clk),
 		.Q(s_clk)
 	);
 	//FSM states		//initialize
 	 localparam[3:0]  start=0,
 							precharge_init=1, 
 							refresh_1=2,
 							refresh_2=3,
 							load_mode_reg=4,
 							//normal operation
 							idle=5,
 							read=6,
 							read_data=7,
 							write=8,
 							write_burst=9,
 							//refresh every 7.81us
 							refresh=10,
 		
 							delay=11; //waiting state for any amount of delay needed
 							
 	//minimum time specs needed(in clks for 143MHz(7ns))
 	localparam[3:0] t_RP=2, //15ns(precharge) 
 					t_RC=6, //60ns(active to active,ref to ref) ///////////////
 					t_MRD=2, //2 clk,(mode register) /2/
 					t_RCD=2, //15ns (active to read/write)      ////////////
 					t_WR=2, //2clk delay after writing before manual/auto precharge can start
 					t_CL=3; //CAS latency(delay of data_out after read command)
 					
 	//commands {cs_n,ras_n,cas_n,we_n} REFER TO THE DATASHEET: winbond W9825G6KH
 	localparam[3:0]  cmd_precharge=4'b0010,
 						  cmd_NOP=4'b0111,
 						  cmd_activate=4'b0011,
 						  cmd_write=4'b0100,
 						  cmd_read=4'b0101,
 						  cmd_setmode=4'b0000,
 						  cmd_refresh=4'b0001;
 						  
 	reg[3:0] state_q,state_d; //_q is registered output, _d is input to DFF
 	reg[3:0] nxt_q,nxt_d; //state after next state
 	reg[3:0] cmd_q,cmd_d; //{cs_n,ras_n,cas_n,we_n}
 	reg[15:0] delay_ctr_q,delay_ctr_d; //stores delay needed(max is 200us for the initialization sequence)
 	reg[10:0] refresh_ctr_q=0,refresh_ctr_d; 
 	reg refresh_flag_q,refresh_flag_d;
 	reg[9:0] burst_index_q=0,burst_index_d; //stores the data left to be burst(512 for full page burst)
 	reg rw_d,rw_q,rw_en_q,rw_en_d;
 	
 	//buffer for output for a glitch-free signal
 	reg[12:0] s_addr_q,s_addr_d;
 	reg[1:0] s_ba_q,s_ba_d;
 	reg[15:0] s_dq_q,s_dq_d;
 	reg tri_q,tri_d;
 	
 	//buffer for input
 	reg[14:0] f_addr_q,f_addr_d;
 	reg[15:0] f2s_data_q,f2s_data_d;
 	reg[15:0] s2f_data_q,s2f_data_d;
 	reg s2f_data_valid_q,s2f_data_valid_d;
 
 	wire[15:0] s_dq_in;
 	wire LDQM,HDQM;
 	reg f2s_data_valid,ready;
 	
 	//register operation
 	always @(posedge clk,negedge rst_n) begin
 		if(!rst_n) begin
 			state_q<=start;
 			nxt_q<=start;
 			cmd_q<=cmd_NOP;
 			delay_ctr_q<=0;
 			refresh_ctr_q<=0;
 			s_addr_q<=0;
 			tri_q<=0;
 			rw_q<=0;
 			rw_en_q<=0;
 			
 			s_ba_q<=0;
 			s_dq_q<=0;
 			f_addr_q<=0;
 			rw_q<=0;
 			f2s_data_q<=0;
 			s2f_data_q<=0;
 			s2f_data_valid_q<=0;
 			rw_q<=0;
 			refresh_flag_q<=0;
 			burst_index_q<=0;
 		end
 		else begin
 			state_q<=state_d;
 			nxt_q<=nxt_d;
 			cmd_q<=cmd_d;
 			delay_ctr_q<=delay_ctr_d;
 			refresh_ctr_q<=refresh_ctr_d;
 			s_addr_q<=s_addr_d;
 			tri_q<=tri_d;
 			refresh_flag_q<=refresh_flag_d;
 			burst_index_q<=burst_index_d;
 			
 			s_ba_q<=s_ba_d;
 			s_dq_q<=s_dq_d;
 			f_addr_q<=f_addr_d;
 			rw_q<=rw_d;
 			f2s_data_q<=f2s_data_d;
 			s2f_data_q<=s2f_data_d;
 			s2f_data_valid_q<=s2f_data_valid_d;
 			rw_q<=rw_d;
 			rw_en_q<=rw_en_d;
 		end
 	end
 	
 
 	//next-state logics
 	always @* begin
 		state_d=state_q;
 		nxt_d=nxt_q;
 		cmd_d=cmd_NOP; //always default to No Operation 
 		delay_ctr_d=delay_ctr_q;
 		ready=0; 
 		s_addr_d=s_addr_q;
 		s_ba_d=s_ba_q;
 		s_dq_d=s_dq_q;
 		f_addr_d=f_addr_q;
 		rw_d=rw_q;
 		f2s_data_d=f2s_data_q;
 		s2f_data_d=s2f_data_q;
 		tri_d=0;  
 		s2f_data_valid_d=1'b0;
 		f2s_data_valid=1'b0;
 		burst_index_d=burst_index_q;
 		rw_d=rw_q;
 		rw_en_d=rw_en_q;
 		
 		//refresh every 7.8us or else data will be lost. 
 		refresh_flag_d=refresh_flag_q;
 		refresh_ctr_d=refresh_ctr_q+1'b1;
 		if(refresh_ctr_q==750) begin //7.7 us
 			refresh_ctr_d=0;
 			refresh_flag_d=1;
 		end
 		
 		
 		
 		case(state_q)
 					////////////////BEGIN:INITIALIZE////////////////
 			delay: begin //wait here for a delay specified by delay_ctr_q(parameter in time specs)
 						delay_ctr_d=delay_ctr_q-1'b1;
 						if(delay_ctr_d==0) state_d=nxt_q;	
 						if(nxt_q==write) tri_d=1;
 					 end
 			start: begin //initiliaze after power-up
 						state_d=delay;
 						nxt_d=precharge_init;
 						delay_ctr_d=16'd30_000; //wait for 200us
 						s_addr_d=0;
 						s_ba_d=0;
 					 end
 precharge_init: begin //precharge ALL banks (A10 must be high)
 						state_d=delay;
 						nxt_d=refresh_1;
 						delay_ctr_d=t_RP-1;
 						cmd_d=cmd_precharge;
 						s_addr_d[10]=1'b1;
 					 end
 		refresh_1: begin
 						state_d=delay;
 						nxt_d=refresh_2;
 						delay_ctr_d=t_RC-1;
 						cmd_d=cmd_refresh;
 					  end
 		refresh_2: begin
 						state_d=delay;
 						nxt_d=load_mode_reg;
 						delay_ctr_d=t_RC-1;
 						cmd_d=cmd_refresh;
 					  end
   load_mode_reg: begin
 						state_d=delay;
 						nxt_d=idle;
 						delay_ctr_d=t_MRD-1;
 						cmd_d=cmd_setmode;
 						s_addr_d=13'b 000_0_00_011_0_111; //{reserved,writemode,reserved,CL,AddressingMode,BurstLength}
 						s_ba_d=2'b00; //reserved
 					  end
 					 ////////////////END:INITIALIZE////////////////
 					
 					////////////////BEGIN:NORMAL OPERATION////////////////
 		     idle: begin 
 						ready=rw_en_q? 0:1;
 						if(rw_en_q) begin //permission granted for r/w operation 
 								state_d=delay;
 								cmd_d=cmd_activate;
 								delay_ctr_d=t_RCD-1;
 								nxt_d=rw_q?read:write;
 								burst_index_d=0;
 								rw_en_d=1'b0;
 								{s_addr_d,s_ba_d}=f_addr_q;//row + bank addr
 						end
 						else if(refresh_flag_q || rw_en) begin  //refresh every 7.7us and BEFORE start of burst read/write operations
 							state_d=delay;
 							nxt_d=refresh;
 							delay_ctr_d=t_RP-1;
 							cmd_d=cmd_precharge; //precharge all banks first before auto-refresh
 							s_addr_d[10]=1'b1;
 							refresh_flag_d=0;
 							if(rw_en) begin 
 								rw_en_d=rw_en;
 								f_addr_d=f_addr; 
 								rw_d=rw;
 							end
 						end
 						
 					  end 
 	     refresh:	begin
 						 state_d=delay;
 						 nxt_d=idle;
 						 delay_ctr_d=t_RC-1;
 						 cmd_d=cmd_refresh;
 						end					 
 			read: begin 
 						state_d=delay;
 						delay_ctr_d=t_CL; //(WHYYY???)not subtracted by one since the sdram is "late" by half a cycle so register is one clk after the expected clock latency delay
 						cmd_d=cmd_read;
 						s_addr_d=0;//what column to activate(in full page mode, column starts at LEFTMOST which is zero)
 						s_ba_d=f_addr_q[1:0]; //what bank to activate
 						s_addr_d[10]=1'b0; //no auto-precharge for full page burst
 						nxt_d=read_data;
 					end
 	 read_data: begin //read data after CAS latency of 3 clk
 						s2f_data_d=s_dq_in;
 						s2f_data_valid_d=1'b1;
 						burst_index_d=burst_index_q+1;
 						if(burst_index_q==512) begin //if all 512 burst data is already finished, precharge then go back to idle
 							s2f_data_valid_d=1'b0;
 							state_d=delay;
 							nxt_d=idle;
 							delay_ctr_d=t_RP-1;
 							cmd_d=cmd_precharge;
 						end
 					end		
 		 write: begin  
 						f2s_data_d=f2s_data; //write data
 						f2s_data_valid=1'b1;
 						s_addr_d=0; //what column to activate(in full page mode, column starts at LEFTMOST which is zero)
 						s_ba_d=f_addr_q[1:0];
 						s_addr_d[10]=1'b0; //no auto-precharge for full page burst
 						tri_d=1'b1; //tristate buffer on since we output/write signals
 						cmd_d=cmd_write;
 						state_d=write_burst;
 						burst_index_d=burst_index_q+1;
 				   end
   write_burst: begin    //write data burst will start at assertion of f2s_data_valid
 						f2s_data_d=f2s_data; //write data
 						f2s_data_valid=1'b1; 
 						tri_d=1'b1; //tristate buffer on since we output/write signals
 						burst_index_d=burst_index_q+1;
 						
 						if(burst_index_q==512) begin //if all 512 burst data is already finished, precharge then go back to idle
 							tri_d=0;
 							state_d=delay;
 							f2s_data_valid=1'b0;
 							nxt_d=idle;
 							delay_ctr_d=t_RP+t_WR-1;
 							cmd_d=cmd_precharge;
 						end
 					end
 				  ////////////////END:NORMAL OPERATION////////////////
 				  
 		default: state_d=start;
 		endcase
 		
 		
 			
 	
 	end
 	
 	//assign the outputs to corresponding buffers
 	assign s_cs_n=cmd_q[3],
 			 s_ras_n=cmd_q[2],
 			 s_cas_n=cmd_q[1],
 			 s_we_n=cmd_q[0];
 	assign s_cke=1'b1; 
 	assign LDQM=1'b0, 
 			 HDQM=1'b0;
 	assign s_addr=s_addr_q;
 	assign s_ba=s_ba_q;
     //assign s_dq=tri_q? f2s_data_q:16'hzzzz; //tri-state output,tri=1 for write , tri=0 for read(hi-Z)
     //assign s_dq_in=s_dq;
 	assign s2f_data=s2f_data_q;
 	assign s2f_data_valid=s2f_data_valid_q;
 	assign s_dqm={HDQM,LDQM};
 	
 	
 
 	genvar i;
 	generate
 		for(i=0;i<16;i=i+1) begin
 			TRELLIS_IO #(.DIR("BIDIR")) u0
 			 (
 			  .B(s_dq[i]),
 			  .I(f2s_data_q[i]),
 			  .T({!tri_q}),
 			  .O(s_dq_in[i])
 			 );
 		end
 	endgenerate
 
endmodule
//---- Top entity
module v726f8b (
 input v06babe,
 input vb72568,
 input v62a627,
 input [15:0] v43e567,
 output v9cfd06,
 output vce526d,
 output [3:0] v3dc608
);
 wire [0:7] w0;
 wire [0:7] w1;
 wire [0:7] w2;
 wire [0:1] w3;
 wire [0:1] w4;
 wire [0:1] w5;
 wire [0:1] w6;
 wire [0:10] w7;
 wire [0:10] w8;
 wire w9;
 wire w10;
 wire [0:15] w11;
 wire w12;
 wire [0:3] w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 assign w9 = vb72568;
 assign w10 = v62a627;
 assign w11 = v43e567;
 assign vce526d = w12;
 assign v3dc608 = w13;
 assign w14 = v06babe;
 assign v9cfd06 = w19;
 assign w17 = w16;
 assign w18 = w15;
 assign w19 = w16;
 assign w19 = w17;
 v62743d vfdf156 (
  .v7d92a9(w14),
  .v59e075(w15),
  .vf8ffa2(w16)
 );
 v45dab8 v6eb500 (
  .v537e7f(w0),
  .v107509(w1),
  .v6025d7(w2),
  .v10aa67(w3),
  .vb39924(w4),
  .v1ace6d(w5),
  .v30f9a1(w6),
  .veb1d23(w7),
  .va0ee93(w8),
  .vd4b130(w17),
  .vef38fc(w18),
  .v7f6c3e(w20)
 );
 v726f8b_ve858d4 ve858d4 (
  .red(w0),
  .green(w1),
  .blue(w2),
  .tmds_red(w3),
  .tmds_green(w4),
  .tmds_blue(w5),
  .tmds_clk(w6),
  .pixel_x(w7),
  .pixel_y(w8),
  .rst_n(w9),
  .empty_fifo(w10),
  .din(w11),
  .rd_en(w12),
  .gpdi_dp(w13),
  .clk_5x(w15),
  .clk_vga(w16),
  .blank(w20)
 );
endmodule

//---------------------------------------------------
//-- hdmi_interface
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Receives pixel data from SDRAM to be displayed on monitor
//---------------------------------------------------

module v726f8b_ve858d4 (
 input clk_5x,
 input clk_vga,
 input rst_n,
 input empty_fifo,
 input [15:0] din,
 input blank,
 input [1:0] tmds_red,
 input [1:0] tmds_green,
 input [1:0] tmds_blue,
 input [1:0] tmds_clk,
 input [10:0] pixel_x,
 input [10:0] pixel_y,
 output rd_en,
 output [3:0] gpdi_dp,
 output [7:0] red,
 output [7:0] green,
 output [7:0] blue
);
 	 reg rd_en;
 	 //FSM state declarations
 	 localparam delay=0,
 					idle=1,
 					display=2;
 					
 	 reg[1:0] state_q,state_d;
 	 reg[7:0] red,green,blue;
 	 wire[1:0] tmds_red,tmds_green,tmds_blue,tmds_clk;
 	 wire clk_5x;
 	 
 	 //register operations
 	 always @(posedge clk_vga,negedge rst_n) begin
 		if(!rst_n) begin
 			state_q<=delay;
 		end
 		else begin
 			state_q<=state_d;
 		end
 	 end
 	 
 	 //FSM next-state logic
 	 always @* begin
 	 state_d=state_q;
 	 rd_en=0;
 	 red=0;
 	 green=0;
 	 blue=0;
 			
 		case(state_q)
 		  delay: if(pixel_x==640 && pixel_y==480) state_d=idle; //delay of one frame(33ms) needed to start up the camera
 			idle:  if(pixel_x==0 && pixel_y==0 && !empty_fifo) begin //wait for pixel-data coming from asyn_fifo 								
 							red=din[15:11]<<3;
 							green=din[10:5]<<2;
 							blue=din[4:0]<<3;
 							rd_en=1;	
 							state_d=display;
 					end
 		display: if(!blank) begin //we will continue to read the asyn_fifo as long as current pixel coordinate is inside the visible screen(640x480) 
 							red=din[15:11]<<3;
 							green=din[10:5]<<2;
 							blue=din[4:0]<<3;
 							rd_en=1;	
 					end
 		default: state_d=delay;
 		endcase
 	 end
  
 	
 	//ODDR instantiatons for Double-Data Rate operation
 		ODDRX1F ddr0_clock (.D0(tmds_clk   [0] ), .D1(tmds_clk   [1] ), .Q(gpdi_dp[3]), .SCLK(clk_5x), .RST(0));
         ODDRX1F ddr0_red   (.D0(tmds_red   [0] ), .D1(tmds_red   [1] ), .Q(gpdi_dp[2]), .SCLK(clk_5x), .RST(0));
         ODDRX1F ddr0_green (.D0(tmds_green [0] ), .D1(tmds_green [1] ), .Q(gpdi_dp[1]), .SCLK(clk_5x), .RST(0));
         ODDRX1F ddr0_blue  (.D0(tmds_blue  [0] ), .D1(tmds_blue  [1] ), .Q(gpdi_dp[0]), .SCLK(clk_5x), .RST(0));
 		
 		
endmodule
//---- Top entity
module v62743d (
 input v7d92a9,
 output v59e075,
 output vf8ffa2
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v7d92a9;
 assign vf8ffa2 = w1;
 assign v59e075 = w2;
 v62743d_v829c03 v829c03 (
  .clkin(w0),
  .clkout1(w1),
  .clkout0(w2)
 );
endmodule

//---------------------------------------------------
//-- pll_HDMI
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Converts 25MHz clk to 25MHz(VGA) and 125MHz(HDMI)
//---------------------------------------------------

module v62743d_v829c03 (
 input clkin,
 output clkout0,
 output clkout1
);
 wire locked;
 
 (* FREQUENCY_PIN_CLKI="25" *)
 (* FREQUENCY_PIN_CLKOP="125" *)
 (* FREQUENCY_PIN_CLKOS="25" *)
 (* ICP_CURRENT="12" *) (* LPF_RESISTOR="8" *) (* MFG_ENABLE_FILTEROPAMP="1" *) (* MFG_GMCREF_SEL="2" *)
 EHXPLLL #(
         .PLLRST_ENA("DISABLED"),
         .INTFB_WAKE("DISABLED"),
         .STDBY_ENABLE("DISABLED"),
         .DPHASE_SOURCE("DISABLED"),
         .OUTDIVIDER_MUXA("DIVA"),
         .OUTDIVIDER_MUXB("DIVB"),
         .OUTDIVIDER_MUXC("DIVC"),
         .OUTDIVIDER_MUXD("DIVD"),
         .CLKI_DIV(1),
         .CLKOP_ENABLE("ENABLED"),
         .CLKOP_DIV(5),
         .CLKOP_CPHASE(2),
         .CLKOP_FPHASE(0),
         .CLKOS_ENABLE("ENABLED"),
         .CLKOS_DIV(25),
         .CLKOS_CPHASE(2),
         .CLKOS_FPHASE(0),
         .FEEDBK_PATH("CLKOP"),
         .CLKFB_DIV(5)
     ) pll_i (
         .RST(1'b0),
         .STDBY(1'b0),
         .CLKI(clkin),
         .CLKOP(clkout0),
         .CLKOS(clkout1),
         .CLKFB(clkout0),
         .CLKINTFB(),
         .PHASESEL0(1'b0),
         .PHASESEL1(1'b0),
         .PHASEDIR(1'b1),
         .PHASESTEP(1'b1),
         .PHASELOADREG(1'b1),
         .PLLWAKESYNC(1'b0),
         .ENCLKOP(1'b0),
         .LOCK(locked)
 	);
endmodule
//---- Top entity
module v45dab8 (
 input vd4b130,
 input vef38fc,
 input [7:0] v537e7f,
 input [7:0] v107509,
 input [7:0] v6025d7,
 output v7f6c3e,
 output [10:0] veb1d23,
 output [10:0] va0ee93,
 output [1:0] v10aa67,
 output [1:0] vb39924,
 output [1:0] v1ace6d,
 output [1:0] v30f9a1
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire [0:7] w9;
 wire [0:7] w10;
 wire [0:7] w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire [0:9] w18;
 wire w19;
 wire [0:1] w20;
 wire [0:1] w21;
 wire [0:1] w22;
 wire [0:1] w23;
 wire [0:9] w24;
 wire [0:9] w25;
 wire [0:10] w26;
 wire [0:10] w27;
 wire w28;
 assign w0 = vd4b130;
 assign w2 = vd4b130;
 assign w3 = vd4b130;
 assign w4 = vd4b130;
 assign w9 = v537e7f;
 assign w10 = v107509;
 assign w11 = v6025d7;
 assign w19 = vef38fc;
 assign v10aa67 = w20;
 assign vb39924 = w21;
 assign v1ace6d = w22;
 assign v30f9a1 = w23;
 assign veb1d23 = w26;
 assign va0ee93 = w27;
 assign v7f6c3e = w28;
 assign w2 = w0;
 assign w3 = w0;
 assign w3 = w2;
 assign w4 = w0;
 assign w4 = w2;
 assign w4 = w3;
 assign w7 = w6;
 assign w8 = w6;
 assign w8 = w7;
 assign w13 = w12;
 assign w15 = w14;
 assign w28 = w5;
 v45dab8_v18a10e v18a10e (
  .pclk(w0),
  .reset_n(w1),
  .out_blank(w5),
  .out_vsync(w16),
  .out_hsync(w17),
  .out_hcnt(w26),
  .out_vcnt(w27)
 );
 vc83dcd v25cda8 (
  .v608bd9(w1)
 );
 v96f098 v333637 (
  .v0e28cb(w5),
  .vcbab45(w6)
 );
 vc4dd08 vfb69db (
  .v608bd9(w12)
 );
 vc4dd08 v15a0b4 (
  .v608bd9(w14)
 );
 v45dab8_v126bbf v126bbf (
  .tmds_blue(w18),
  .tmds_clk(w19),
  .out_tmds_red(w20),
  .out_tmds_green(w21),
  .out_tmds_blue(w22),
  .out_tmds_clk(w23),
  .tmds_red(w24),
  .tmds_green(w25)
 );
 vcb4e6d vc4fba0 (
  .vdd711c(w2),
  .v3653dc(w6),
  .v11f67f(w9),
  .v015605(w12),
  .vbca4a6(w13),
  .v90c336(w24)
 );
 vcb4e6d ve76285 (
  .vdd711c(w3),
  .v3653dc(w7),
  .v11f67f(w10),
  .v015605(w14),
  .vbca4a6(w15),
  .v90c336(w25)
 );
 vcb4e6d v2f7048 (
  .vdd711c(w4),
  .v3653dc(w8),
  .v11f67f(w11),
  .v015605(w16),
  .vbca4a6(w17),
  .v90c336(w18)
 );
endmodule

//---------------------------------------------------
//-- HDMI_controller
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- HDMI controller with DDR enabled
//---------------------------------------------------

module v45dab8_v18a10e (
 input pclk,
 input reset_n,
 output out_hsync,
 output out_vsync,
 output out_blank,
 output [10:0] out_hcnt,
 output [10:0] out_vcnt
);
 //Copyright (C) 2021 Hirosh Dabui hirosh@dabui.de
 
 localparam
 	/* VGA_1280x720@60Hz */          
 		 VPOL            = 1,	      
 		 HPOL            = 0,	      
 		 FRAME_RATE      = 30,	    
 	/* vertical timing frame */     
 		 VBP             = 33,      
 		 VFP             = 10,      
 		 VSLEN           = 2,	      
 		 VACTIVE         = 480,	    
 	/* horizontal timing frame */   
 		 HBP             = 48,	    
 		 HFP             = 16,	    
 		 HSLEN           = 96,	    
 		 HACTIVE         = 640;
 //////////////////////////////////////
 
 localparam VTOTAL            = VACTIVE + VFP + VSLEN + VBP;	
 localparam HTOTAL            = HACTIVE + HFP + HSLEN + HBP;	
 localparam PIXEL_CLK         = (VTOTAL * HTOTAL) * FRAME_RATE;
 
 reg[10:0] out_hcnt,out_vcnt;
 	//Display Final Values 
 	initial begin 
 	  $display("VACTIVE:%d", VACTIVE); 
 	  $display("HACTIVE:%d", HACTIVE); 
 	  $display("VBP:%d", VBP);
 	  $display("VFP:%d", VFP); 
 	  $display("HBP:%d", HBP); 
 	  $display("HFP:%d", HFP); 
 	  $display("VSLEN:%d", VSLEN); 
 	  $display("HSLEN:%d", HSLEN); 
 	  $display("VTOTAL:%d", VTOTAL); 
 	  $display("HTOTAL:%d", HTOTAL); 
 	  $display("Framerate:%d", FRAME_RATE); 
 	  $display("PIXEL Frequency:%d", PIXEL_CLK); 
 	end 
 	
     /*
      *
      *         +
      *         |
      *         | VACTIVE
      *         |
      *         |       HACTIVE            HFP    HSLEN    HBP
      *         ------------------------++-----++-------+------+
      *         |
      *         |
      *         |
      *         |
      *         |
      *         +
      *         | VFP
      *         +
      *         +
      *         |
      *         | VSLEN
      *         |
      *         +
      *         +
      *         |
      *         | HBP
      *         |
      *         +
      *
      */
 
 
 
 assign out_vsync = ((out_vcnt >= (VACTIVE + VFP -1)) && (out_vcnt < (VACTIVE + VFP + VSLEN))) ^ ~VPOL;
 assign out_hsync = ((out_hcnt >= (HACTIVE + HFP -1)) && (out_hcnt < (HACTIVE + HFP + HSLEN))) ^ ~HPOL;
 assign out_blank = (out_hcnt >= HACTIVE) || (out_vcnt >= VACTIVE);
 
 wire hcycle = out_hcnt == (HTOTAL -1) || ~reset_n;
 wire vcycle = out_vcnt == (VTOTAL -1) || ~reset_n;
 
 always @(posedge pclk) out_hcnt <= hcycle ? 0 : out_hcnt + 1;
 
 always @(posedge pclk) begin
     if (hcycle) out_vcnt <= vcycle ? 0 : out_vcnt + 1;
 end
 
endmodule

module v45dab8_v126bbf (
 input tmds_clk,
 input [9:0] tmds_red,
 input [9:0] tmds_green,
 input [9:0] tmds_blue,
 output [1:0] out_tmds_red,
 output [1:0] out_tmds_green,
 output [1:0] out_tmds_blue,
 output [1:0] out_tmds_clk
);
 //Copyright (C) 2021 Hirosh Dabui hirosh@dabui.de
 
 localparam DDR_ENABLED=1,
             OUT_TMDS_MSB = DDR_ENABLED ? 1 : 0;
 
 
 /**/
 reg       tmds_shift_load   = 0;
 reg [3:0] tmds_modulo       = 0;
 reg [9:0] tmds_shift_red    = 0;
 reg [9:0] tmds_shift_green  = 0;
 reg [9:0] tmds_shift_blue   = 0;
 reg [9:0] tmds_shift_clk    = 0;
 
 wire [9:0] tmds_pixel_clk = 10'b00000_11111;
 
 
 wire max_shifts_reached = tmds_modulo == (DDR_ENABLED ? 4 : 9);
 always @(posedge tmds_clk) tmds_modulo      <= max_shifts_reached ? 0 : tmds_modulo + 1;
 always @(posedge tmds_clk) tmds_shift_load  <= max_shifts_reached;
 
 always @(posedge tmds_clk) begin //shifts 2-bits at a time if DDR is enabled, else shift 1-bit at a time
     tmds_shift_red    <= tmds_shift_load ? tmds_red       : {DDR_ENABLED ? 2'b00 : 1'b0, tmds_shift_red   [9: DDR_ENABLED ? 2 : 1]};
     tmds_shift_green  <= tmds_shift_load ? tmds_green     : {DDR_ENABLED ? 2'b00 : 1'b0, tmds_shift_green [9: DDR_ENABLED ? 2 : 1]};
     tmds_shift_blue   <= tmds_shift_load ? tmds_blue      : {DDR_ENABLED ? 2'b00 : 1'b0, tmds_shift_blue  [9: DDR_ENABLED ? 2 : 1]};
     tmds_shift_clk    <= tmds_shift_load ? tmds_pixel_clk : {DDR_ENABLED ? 2'b00 : 1'b0, tmds_shift_clk   [9: DDR_ENABLED ? 2 : 1]};
 end
 
 assign out_tmds_clk   = tmds_shift_clk    [ OUT_TMDS_MSB : 0 ];
 assign out_tmds_red   = tmds_shift_red    [ OUT_TMDS_MSB : 0 ];
 assign out_tmds_green = tmds_shift_green  [ OUT_TMDS_MSB : 0 ];
 assign out_tmds_blue  = tmds_shift_blue   [ OUT_TMDS_MSB : 0 ];
endmodule
//---- Top entity
module vc83dcd (
 output v608bd9
);
 wire w0;
 assign v608bd9 = w0;
 vc83dcd_v68c173 v68c173 (
  .v(w0)
 );
endmodule

//---------------------------------------------------
//-- Bit 1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Assign 1 to the output wire
//---------------------------------------------------

module vc83dcd_v68c173 (
 output v
);
 // Bit 1
 
 assign v = 1'b1;
endmodule
//---- Top entity
module v96f098 (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v96f098_vd54ca1 vd54ca1 (
  .a(w0),
  .c(w1)
 );
endmodule

//---------------------------------------------------
//-- NOT
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- NOT logic gate
//---------------------------------------------------

module v96f098_vd54ca1 (
 input a,
 output c
);
 // NOT logic gate
 
 assign c = ~ a;
endmodule
//---- Top entity
module vc4dd08 (
 output v608bd9
);
 wire w0;
 assign v608bd9 = w0;
 vc4dd08_v68c173 v68c173 (
  .v(w0)
 );
endmodule

//---------------------------------------------------
//-- Bit 0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Assign 0 to the output wire
//---------------------------------------------------

module vc4dd08_v68c173 (
 output v
);
 // Bit 0
 
 assign v = 1'b0;
endmodule
//---- Top entity
module vcb4e6d (
 input vdd711c,
 input v3653dc,
 input [7:0] v11f67f,
 input v015605,
 input vbca4a6,
 output [9:0] v90c336
);
 wire [0:9] w0;
 wire w1;
 wire w2;
 wire [0:7] w3;
 wire w4;
 wire w5;
 assign v90c336 = w0;
 assign w1 = vdd711c;
 assign w2 = v3653dc;
 assign w3 = v11f67f;
 assign w4 = v015605;
 assign w5 = vbca4a6;
 vcb4e6d_v07d31b v07d31b (
  .q_out(w0),
  .clk(w1),
  .DE(w2),
  .D(w3),
  .C1(w4),
  .C0(w5)
 );
endmodule

//---------------------------------------------------
//-- tmds_encoder
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 
//---------------------------------------------------

module vcb4e6d_v07d31b (
 input clk,
 input DE,
 input [7:0] D,
 input C1,
 input C0,
 output [9:0] q_out
);
 //Copyright (C) 2021 Hirosh Dabui hirosh@dabui.de
 
 parameter LEGACY_DVI_CONTROL_LUT = 0;
 reg[9:0] q_out;
 function [3:0] N0;
     input [7:0] d;
     integer i;
     begin
         N0 = 0;
         for (i = 0; i < 8; i=i+1)
             N0 = N0 + !d[i];
     end
 endfunction
 
 function [3:0] N1;
     input [7:0] d;
     integer i;
     begin
         N1 = 0;
         for (i = 0; i < 8; i=i+1)
             N1 = N1 + d[i];
     end
 endfunction
 
 reg signed [7:0] cnt_prev = 0;
 reg signed [7:0] cnt = 0;
 
 reg [8:0] q_m;
 
 always @(*) begin
 
     if ( (N1(D) > 4) | (N1(D) == 4) & (D[0] == 0) ) begin
 
         q_m[0] =           D[0];
         q_m[1] = q_m[0] ~^ D[1];
         q_m[2] = q_m[1] ~^ D[2];
         q_m[3] = q_m[2] ~^ D[3];
         q_m[4] = q_m[3] ~^ D[4];
         q_m[5] = q_m[4] ~^ D[5];
         q_m[6] = q_m[5] ~^ D[6];
         q_m[7] = q_m[6] ~^ D[7];
         q_m[8] = 1'b0;
 
     end else begin
 
         q_m[0] =          D[0];
         q_m[1] = q_m[0] ^ D[1];
         q_m[2] = q_m[1] ^ D[2];
         q_m[3] = q_m[2] ^ D[3];
         q_m[4] = q_m[3] ^ D[4];
         q_m[5] = q_m[4] ^ D[5];
         q_m[6] = q_m[5] ^ D[6];
         q_m[7] = q_m[6] ^ D[7];
         q_m[8] = 1'b1;
 
     end /* (N1(D) > 4) | (N1(D) == 4) & (D[0] == 0) */
 
 end
 
 always @(posedge clk) begin
 
     if (DE) begin
 
         if ((cnt_prev == 0) | (N1(q_m[7:0]) == N0(q_m[7:0]))) begin
 
             q_out[9]   <= ~q_m[8];
             q_out[8]   <=  q_m[8];
             q_out[7:0] <= q_m[8] ? q_m[7:0] : ~q_m[7:0];
 
             if (q_m[8] == 0) begin
                 cnt = cnt_prev + (N0(q_m[7:0]) - N1(q_m[7:0]));
             end else begin
                 cnt = cnt_prev + (N1(q_m[7:0]) - N0(q_m[7:0]));
             end /*q_m[8] == 0*/
 
         end else begin
 
             if ( (cnt_prev > 0 & (N1(q_m[7:0]) > N0(q_m[7:0]))) |
                     (cnt_prev < 0 & (N0(q_m[7:0]) > N1(q_m[7:0]))) ) begin
                 q_out[9] <= 1;
                 q_out[8] <= q_m[8];
                 q_out[7:0] <= ~q_m[7:0];
                 cnt = cnt_prev + 2*q_m[8] + (N0(q_m[7:0]) - N1(q_m[7:0]));
             end else begin
                 q_out[9] <= 0;
                 q_out[8] <= q_m[8];
                 q_out[7:0] <= q_m[7:0];
                 cnt = cnt_prev + 2*(~q_m[8]) + (N1(q_m[7:0]) - N0(q_m[7:0]));
             end /*
                 (cnt_prev > 0 & N1(q_m[7:0]) > N0(q_m[7:0]))) |
                 (cnt_prev < 0 & N0(q_m[7:0]) > N1(q_m[7:0])))
               */
 
         end /* ((cnt_prev == 0) | (N1(q_m[7:0]) == N0(q_m[7:0]))) */
 
     end else begin
         /* !DE */
         cnt = 0;
         /* hsync -> c0 | vsync -> c1 */
         case ({C1, C0})
 `ifdef LEGACY_DVI_CONTROL_LUT
             /* dvi control data lut */
             2'b00: q_out <= 10'b00101_01011;
             2'b01: q_out <= 10'b11010_10100;
             2'b10: q_out <= 10'b00101_01010;
             2'b11: q_out <= 10'b11010_10101;
 `else
             /* hdmi control data period */
             2'b00: q_out <= 10'b1101010100;
             2'b01: q_out <= 10'b0010101011;
             2'b10: q_out <= 10'b0101010100;
             2'b11: q_out <= 10'b1010101011;
 `endif
         endcase
 
     end /* DE */
 
     cnt_prev <= cnt;
 
 end
 
endmodule
