// Code generated by Icestudio 0.12

`default_nettype none

//---- Top entity
module main (
 input v40f83b,
 input v58a987,
 input v43545c,
 input vfd491d,
 input vab4d84,
 input v2b4127,
 input v666f4e,
 input v244572,
 input [7:0] vef8052,
 output vb5062e,
 output v094fae,
 output [3:0] v814efa,
 output v74a75f,
 output vaa23fa,
 output vfca177,
 output [7:0] v115c4a,
 output v80d23e,
 output [12:0] v5dce43,
 output [15:0] vd005a1,
 output v7b1797,
 output vac2304,
 output v039554,
 output v22789a,
 output v7ff59b,
 output [1:0] v26f936,
 output [1:0] v9e17cc
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire [0:15] w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire [0:7] w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire [0:7] w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire [0:12] w27;
 wire [0:1] w28;
 wire [0:1] w29;
 wire [0:3] w30;
 wire w31;
 wire [0:10] w32;
 wire [0:15] w33;
 wire w34;
 wire w35;
 wire [0:16] w36;
 wire w37;
 wire [0:16] w38;
 wire w39;
 wire [0:10] w40;
 wire w41;
 wire w42;
 wire [0:10] w43;
 wire w44;
 wire w45;
 wire [0:8] w46;
 wire [0:7] w47;
 wire w48;
 wire w49;
 wire w50;
 assign w0 = v40f83b;
 assign w1 = v40f83b;
 assign w2 = v58a987;
 assign w3 = v58a987;
 assign w4 = v58a987;
 assign w7 = v40f83b;
 assign v7b1797 = w11;
 assign vac2304 = w12;
 assign v115c4a = w13;
 assign v039554 = w14;
 assign v22789a = w15;
 assign v7ff59b = w16;
 assign w17 = v2b4127;
 assign w18 = v666f4e;
 assign w19 = v244572;
 assign w20 = vef8052;
 assign vb5062e = w21;
 assign v094fae = w22;
 assign v74a75f = w23;
 assign vaa23fa = w24;
 assign vfca177 = w25;
 assign v80d23e = w26;
 assign v5dce43 = w27;
 assign v26f936 = w28;
 assign v9e17cc = w29;
 assign v814efa = w30;
 assign vd005a1 = w33;
 assign w34 = v58a987;
 assign w37 = v40f83b;
 assign w48 = v43545c;
 assign w49 = vfd491d;
 assign w50 = vab4d84;
 assign w1 = w0;
 assign w3 = w2;
 assign w4 = w2;
 assign w4 = w3;
 assign w7 = w0;
 assign w7 = w1;
 assign w31 = w6;
 assign w34 = w2;
 assign w34 = w3;
 assign w34 = w4;
 assign w37 = w0;
 assign w37 = w1;
 assign w37 = w7;
 assign w39 = w6;
 assign w39 = w31;
 assign w45 = w44;
 vc187a2 v3383b1 (
  .v6a4126(w0),
  .vc57e23(w6)
 );
 vf72cc6 vc07f95 (
  .v675708(w1),
  .v184dc1(w2),
  .v663e83(w5),
  .v744219(w11),
  .v3d8de7(w12),
  .vc26e9a(w13),
  .v92c601(w14),
  .vb229cc(w15),
  .vc308e6(w16),
  .v9ce3e7(w17),
  .vd89e9b(w18),
  .v8934f6(w19),
  .v7e1080(w20),
  .v5af38e(w31),
  .v694ba6(w32),
  .v7bd7f8(w36),
  .v161aca(w38),
  .v66862d(w40),
  .v77f5c3(w42)
 );
 v2b8124 v50aef8 (
  .v1f84c3(w3),
  .v826765(w5),
  .vef4a17(w6),
  .v1417c5(w8),
  .v8284ba(w9),
  .v966dc3(w10),
  .vf84337(w21),
  .v8017c3(w22),
  .ve90166(w23),
  .v917e66(w24),
  .v7699e6(w25),
  .va88c3b(w26),
  .v2a425f(w27),
  .v4de55f(w28),
  .v140121(w29),
  .v3aa53b(w32),
  .vce2330(w33),
  .v831e9c(w35),
  .ve6ca0d(w36),
  .v90eda9(w41),
  .v047d0f(w43),
  .v78b3e5(w44),
  .vb68f1b(w46)
 );
 vacc707 v0d9a98 (
  .vb72568(w4),
  .v06babe(w7),
  .v43e567(w8),
  .v9cfd06(w9),
  .vce526d(w10),
  .v3dc608(w30),
  .v62a627(w35),
  .vc12365(w45),
  .v974bf7(w47)
 );
 v215c29 v32ef04 (
  .vac6e8a(w34),
  .v1330f7(w37),
  .va6a902(w38),
  .v4b9b10(w39),
  .v8418a8(w40),
  .v3f3eec(w41),
  .v3024c9(w42),
  .v312c43(w43),
  .v2775c6(w44),
  .vfe3990(w46),
  .v4c8564(w47),
  .v6391f5(w48),
  .vfdf113(w49),
  .v2c85c6(w50)
 );
endmodule

//---------------------------------------------------
//-- asyn_fifo
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- fifo with different read/write clock domains
//---------------------------------------------------
//---- Top entity
module vc187a2 (
 input v6a4126,
 output vc57e23
);
 wire w0;
 wire w1;
 assign w0 = v6a4126;
 assign vc57e23 = w1;
 vc187a2_v32750d v32750d (
  .clkin(w0),
  .clkout0(w1)
 );
endmodule

//---------------------------------------------------
//-- pll_SDRAM
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Converts 25MHz input clk to 100MHz
//---------------------------------------------------

module vc187a2_v32750d (
 input clkin,
 output clkout0
);
 wire locked;
 
 (* FREQUENCY_PIN_CLKI="25" *)
 (* FREQUENCY_PIN_CLKOP="142.857" *)
 (* ICP_CURRENT="12" *) (* LPF_RESISTOR="8" *) (* MFG_ENABLE_FILTEROPAMP="1" *) (* MFG_GMCREF_SEL="2" *)
 EHXPLLL #(
         .PLLRST_ENA("DISABLED"),
         .INTFB_WAKE("DISABLED"),
         .STDBY_ENABLE("DISABLED"),
         .DPHASE_SOURCE("DISABLED"),
         .OUTDIVIDER_MUXA("DIVA"),
         .OUTDIVIDER_MUXB("DIVB"),
         .OUTDIVIDER_MUXC("DIVC"),
         .OUTDIVIDER_MUXD("DIVD"),
         .CLKI_DIV(7),
         .CLKOP_ENABLE("ENABLED"),
         .CLKOP_DIV(4),
         .CLKOP_CPHASE(1),
         .CLKOP_FPHASE(0),
         .FEEDBK_PATH("CLKOP"),
         .CLKFB_DIV(40)
     ) pll_i (
         .RST(1'b0),
         .STDBY(1'b0),
         .CLKI(clkin),
         .CLKOP(clkout0),
         .CLKFB(clkout0),
         .CLKINTFB(),
         .PHASESEL0(1'b0),
         .PHASESEL1(1'b0),
         .PHASEDIR(1'b1),
         .PHASESTEP(1'b1),
         .PHASELOADREG(1'b1),
         .PLLWAKESYNC(1'b0),
         .ENCLKOP(1'b0),
         .LOCK(locked)
 	);
endmodule
//---- Top entity
module vf72cc6 #(
 parameter v15a1ce = "v15a1ce.list"
) (
 input v663e83,
 input v5af38e,
 input v184dc1,
 input v9ce3e7,
 input v77f5c3,
 input vd89e9b,
 input v8934f6,
 input [7:0] v7e1080,
 input v675708,
 input v3f0c04,
 input v9cc115,
 input v5bf874,
 input vbed5b3,
 output [10:0] v694ba6,
 output [16:0] v7bd7f8,
 output v744219,
 output v3d8de7,
 output [10:0] v66862d,
 output [16:0] v161aca,
 output [7:0] vc26e9a,
 output v92c601,
 output vb229cc,
 output vc308e6
);
 localparam p33 = v15a1ce;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire [0:7] w5;
 wire w6;
 wire w7;
 wire [0:7] w8;
 wire w9;
 wire w10;
 wire w11;
 wire [0:1] w12;
 wire [0:3] w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire w27;
 wire w28;
 wire w29;
 wire [0:7] w30;
 wire [0:10] w31;
 wire w32;
 wire w34;
 wire w35;
 wire w36;
 wire w37;
 wire w38;
 wire w39;
 wire w40;
 wire w41;
 wire w42;
 wire [0:10] w43;
 wire [0:16] w44;
 wire [0:16] w45;
 wire [0:16] w46;
 wire [0:16] w47;
 assign w0 = v5af38e;
 assign w1 = v184dc1;
 assign w2 = v9ce3e7;
 assign w3 = vd89e9b;
 assign w4 = v8934f6;
 assign w5 = v7e1080;
 assign v744219 = w6;
 assign v3d8de7 = w7;
 assign vc26e9a = w8;
 assign w9 = v5af38e;
 assign w10 = v184dc1;
 assign vb229cc = w11;
 assign v92c601 = w14;
 assign w14 = v675708;
 assign vc308e6 = w15;
 assign w16 = v3f0c04;
 assign w17 = v9cc115;
 assign w18 = v5bf874;
 assign w19 = vbed5b3;
 assign w20 = v675708;
 assign w21 = v675708;
 assign w22 = v675708;
 assign w23 = v184dc1;
 assign w24 = v5af38e;
 assign w25 = v5af38e;
 assign w27 = v663e83;
 assign v694ba6 = w31;
 assign w32 = v675708;
 assign w38 = v184dc1;
 assign w39 = v5af38e;
 assign w40 = v675708;
 assign w42 = v77f5c3;
 assign v66862d = w43;
 assign v161aca = w46;
 assign v7bd7f8 = w47;
 assign w9 = w0;
 assign w10 = w1;
 assign w20 = w14;
 assign w21 = w14;
 assign w21 = w20;
 assign w22 = w14;
 assign w22 = w20;
 assign w22 = w21;
 assign w23 = w1;
 assign w23 = w10;
 assign w24 = w0;
 assign w24 = w9;
 assign w25 = w0;
 assign w25 = w9;
 assign w25 = w24;
 assign w32 = w14;
 assign w32 = w20;
 assign w32 = w21;
 assign w32 = w22;
 assign w38 = w1;
 assign w38 = w10;
 assign w38 = w23;
 assign w39 = w0;
 assign w39 = w9;
 assign w39 = w24;
 assign w39 = w25;
 assign w40 = w14;
 assign w40 = w20;
 assign w40 = w21;
 assign w40 = w22;
 assign w40 = w32;
 assign w41 = w26;
 assign w45 = w44;
 vcfd9ba vcda321 (
  .v6a82dd(w16),
  .v444878(w32),
  .vd4e5d7(w34)
 );
 vcfd9ba v09aef4 (
  .v6a82dd(w17),
  .v444878(w20),
  .vd4e5d7(w35)
 );
 vcfd9ba v7e24a5 (
  .v6a82dd(w18),
  .v444878(w21),
  .vd4e5d7(w36)
 );
 vcfd9ba vea3248 (
  .v6a82dd(w19),
  .v444878(w22),
  .vd4e5d7(w37)
 );
 v96ca63 v385830 (
  .v6ead63(w9),
  .vd0348a(w10),
  .vb03459(w11),
  .va203ef(w12),
  .v967217(w13),
  .v6a1f4c(w15),
  .v63e08d(w28),
  .ve9b86c(w29),
  .vc4be01(w30)
 );
 vf72cc6_v93ba14 #(
  .DATA(p33)
 ) v93ba14 (
  .clk_100(w0),
  .rst_n(w1),
  .cmos_pclk(w2),
  .cmos_href(w3),
  .cmos_vsync(w4),
  .cmos_db(w5),
  .cmos_rst_n(w6),
  .cmos_pwdn(w7),
  .led(w8),
  .ack(w12),
  .state(w13),
  .wr_en(w26),
  .start(w28),
  .stop(w29),
  .wr_data(w30),
  .key0(w34),
  .key1(w35),
  .key2(w36),
  .key3(w37),
  .pixel_q(w44)
 );
 v0644e6 v41db97 (
  .v154578(w23),
  .vc312eb(w24),
  .v14fb5c(w25),
  .vbecff9(w26),
  .v88873d(w27),
  .vffb9ca(w31),
  .v9cc419(w44),
  .v6cc6df(w47)
 );
 ve6a150 vdb3cff (
  .v154578(w38),
  .vc312eb(w39),
  .v14fb5c(w40),
  .vbecff9(w41),
  .v88873d(w42),
  .vffb9ca(w43),
  .v9cc419(w45),
  .v6cc6df(w46)
 );
endmodule

//---------------------------------------------------
//-- camera_interface
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- communicates with OV7670 and set register configurations
//---------------------------------------------------

module vf72cc6_v93ba14 #(
 parameter DATA = 0
) (
 input clk_100,
 input rst_n,
 input cmos_pclk,
 input cmos_href,
 input cmos_vsync,
 input [7:0] cmos_db,
 input [1:0] ack,
 input [3:0] state,
 input key0,
 input key1,
 input key2,
 input key3,
 output cmos_rst_n,
 output cmos_pwdn,
 output [7:0] led,
 output start,
 output stop,
 output [7:0] wr_data,
 output wr_en,
 output [16:0] pixel_q
);
 	 //FSM state declarations
 	 localparam idle=0,
 					start_sccb=1,
 					write_address=2,
 					write_data=3,
 					digest_loop=4,
 					delay=5,
 					vsync_fedge=6,
 					byte1=7,
 					byte2=8,
 					fifo_write=9,
 					stopping=10;
 					
 	 localparam wait_init=0,
 					sccb_idle=1,
 					sccb_address=2,
 					sccb_data=3,
 					sccb_stop=4;
 					
 	 localparam MSG_INDEX=77; //number of the last index to be digested by SCCB
 	 
 	 
 	 
 	 reg[3:0] state_q=0,state_d;
 	 reg[2:0] sccb_state_q=0,sccb_state_d;
 	 reg[7:0] addr_q,addr_d;
 	 reg[7:0] data_q,data_d;
 	 reg[7:0] brightness_q,brightness_d;
 	 reg[7:0] contrast_q,contrast_d;
 	 reg start,stop;
 	 reg[7:0] wr_data;
 	 reg[7:0] led_q=0,led_d; 
 	 reg[27:0] delay_q=0,delay_d;
 	 reg start_delay_q=0,start_delay_d;
 	 reg delay_finish;
 	 reg[20:0] message[250:0];
 	 reg[7:0] message_index_q=0,message_index_d;
 	 reg[16:0] pixel_q,pixel_d;
 	 reg wr_en;
 	 reg key0_tick,key1_tick,key2_tick,key3_tick;
 	 reg key0_prev,key1_prev,key2_prev,key3_prev;
 	 
 	 wire rd_tick;
 	 wire[7:0] rd_data;
 	 wire full;
 	 
 	 //buffer for all inputs coming from the camera
 	 reg pclk_1,pclk_2,href_1,href_2,vsync_1,vsync_2;
 	 
      initial begin  //read all register configuration values
         if(DATA) $readmemh(DATA,message);
      end
     
 	 
 	 //register operations
 	 always @(posedge clk_100,negedge rst_n) begin
 		if(!rst_n) begin
 			state_q<=0;
 			led_q<=0;
 			delay_q<=0;
 			start_delay_q<=0;
 			message_index_q<=0;
 			pixel_q<=0;
 			
 			sccb_state_q<=0;
 			addr_q<=0;
 			data_q<=0;
 			brightness_q<=0;
 			contrast_q<=0;
 		end
 		else begin
 			state_q<=state_d;
 			led_q<=led_d;
 			delay_q<=delay_d;
 			start_delay_q<=start_delay_d;
 			message_index_q<=message_index_d;			
 			pclk_1<=cmos_pclk; 
 			pclk_2<=pclk_1;
 			href_1<=cmos_href;
 			href_2<=href_1;
 			vsync_1<=cmos_vsync;
 			vsync_2<=vsync_1;
 			pixel_q<=pixel_d;
 			
 			sccb_state_q<=sccb_state_d;
 			addr_q<=addr_d;
 			data_q<=data_d;
 			brightness_q<=brightness_d;
 			contrast_q<=contrast_d;
 		end
 	 end
 	 	 
 	 
 	 //FSM next-state logics
 	 always @* begin
 		state_d=state_q;
 		led_d=led_q;
 		start=0;
 		stop=0;
 		wr_data=0;
 		start_delay_d=start_delay_q;
 		delay_d=delay_q;
 		delay_finish=0;
 		message_index_d=message_index_q;
 		pixel_d=pixel_q;
 		wr_en=0;
 		
 		sccb_state_d=sccb_state_q;
 		addr_d=addr_q;
 		data_d=data_q;
 		brightness_d=brightness_q;
 		contrast_d=contrast_q;
 		
 		//delay logic  
 		if(start_delay_q) delay_d=delay_q+1'b1;
 		if(delay_q[16] && message_index_q!=(MSG_INDEX+1) && (state_q!=start_sccb))  begin  //delay between SCCB transmissions (0.66ms)
 			delay_finish=1;
 			start_delay_d=0;
 			delay_d=0;
 		end
 		else if((delay_q[26] && message_index_q==(MSG_INDEX+1)) || (delay_q[26] && state_q==start_sccb)) begin //delay BEFORE SCCB transmission, AFTER SCCB transmission, and BEFORE retrieving pixel data from camera (0.67s)
 			delay_finish=1;
 			start_delay_d=0;
 			delay_d=0;
 		end
 		
 		case(state_q) 
 		
 					////////Begin: Setting register values of the camera via SCCB///////////
 					
 			  idle:  if(delay_finish) begin //idle for 0.6s to start-up the camera
 							state_d=start_sccb; 
 							start_delay_d=0;
 						end
 						else start_delay_d=1;
 
 		start_sccb:  begin   //start of SCCB transmission
 							start=1;
 							wr_data=8'h42; //slave address of OV7670 for write
 							state_d=write_address;	
 						end
 	 write_address: if(ack==2'b11) begin 
 							wr_data=message[message_index_q][15:8]; //write address
 							state_d=write_data;
 						end
 		 write_data: if(ack==2'b11) begin 
 							wr_data=message[message_index_q][7:0]; //write data
 							state_d=digest_loop;
 						end
 	  digest_loop: if(ack==2'b11) begin //stop sccb transmission
 							stop=1;
 							start_delay_d=1;
 							message_index_d=message_index_q+1'b1;
 							state_d=delay;
 						end
 			  delay: begin
 							if(message_index_q==(MSG_INDEX+1) && delay_finish) begin 
 								state_d=vsync_fedge; //if all messages are already digested, proceed to retrieving camera pixel data
 								led_d=8'b0011_0011; //red LEDs
 							end
 							else if(state==0 && delay_finish) state_d=start_sccb; //small delay before next SCCB transmission(if all messages are not yet digested)
 						end
 			  
 			  
 
 			///////////////Begin: Retrieving Pixel Data from Camera to be Stored to SDRAM/////////////////
 				
 		vsync_fedge: if(vsync_1==1 && vsync_2==1) begin	
 							state_d=byte1; //vsync falling edge means new frame is incoming
 							pixel_d[16]=1;
 					 end
 				byte1: begin
 						if(pclk_1==1 && pclk_2==0 && href_1==1 && href_2==1) begin //rising edge of pclk means new pixel data(first byte of 16-bit pixel RGB565) is available at output
 								pixel_d[15:8]=cmos_db;
 								state_d=byte2;
 						 end
 						 else if(vsync_1==1 && vsync_2==1) begin //new frame incoming
 							pixel_d[16]=1;
 						 end
 					  end
 				byte2: if(pclk_1==1 && pclk_2==0 && href_1==1 && href_2==1) begin //rising edge of pclk means new pixel data(second byte of 16-bit pixel RGB565) is available at output
 								pixel_d[7:0]=cmos_db;
 								state_d=fifo_write;
 								//count_d=(count_q<307200)? (count_q+1'b1):0;
 						 end
 						 else if(vsync_1==1 && vsync_2==1) begin
 							state_d=vsync_fedge;
 						 end
 		 fifo_write: begin //write the 16-bit data to asynchronous fifo to be retrieved later by SDRAM
 								wr_en=1;
 								state_d=byte1;
 								led_d=8'b1100_1100; //debugging led
 								pixel_d[16]=0;
 						 end
 		default: state_d=idle;
 		endcase
 		
 		//Logic for increasing/decreasing brightness and contrast via the 4 keybuttons
 		case(sccb_state_q)
 			wait_init: if(state_q==byte1) begin //wait for initial SCCB transmission to finish
 							sccb_state_d=sccb_idle;
 							addr_d=0;
 							data_d=0;
 							brightness_d=8'h00; 
 							contrast_d=8'h40;
 						  end
 			sccb_idle: if(state==0) begin //wait for any pushbutton
 								if(key0_tick) begin//increase brightness
 									brightness_d=(brightness_q[7]==1)? brightness_q-5:brightness_q+5;
 									if(brightness_q==8'h80) brightness_d=0;
 									start=1;
 									wr_data=8'h42; //slave address of OV7670 for write
 									addr_d=8'h55; //brightness control address
 									data_d=brightness_d;
 									sccb_state_d=sccb_address;
 									led_d=0;
 								end
 								if(key1_tick) begin //decrease brightness
 									brightness_d=(brightness_q[7]==1)? brightness_q+5:brightness_q-5;
 									if(brightness_q==0) brightness_d=8'h80;
 									start=1;
 									wr_data=8'h42; 
 									addr_d=8'h55;
 									data_d=brightness_d;
 									sccb_state_d=sccb_address;
 									led_d=0;
 								end
 								else if(key2_tick) begin //increase contrast
 									contrast_d=contrast_q+5;
 									start=1;
 									wr_data=8'h42; //slave address of OV7670 for write
 									addr_d=8'h56; //contrast control address
 									data_d=contrast_d;
 									sccb_state_d=sccb_address;
 									led_d=0;
 								end
 								else if(key3_tick) begin //change contrast
 									contrast_d=contrast_q-5;
 									start=1;
 									wr_data=8'h42;
 									addr_d=8'h56;
 									data_d=contrast_d;
 									sccb_state_d=sccb_address;
 									led_d=0;
 								end
 						  end
 		sccb_address: if(ack==2'b11) begin 
 							wr_data=addr_q; //write address
 							sccb_state_d=sccb_data;
 						end
 		  sccb_data: if(ack==2'b11) begin 
 							wr_data=data_q; //write databyte
 							sccb_state_d=sccb_stop;
 						 end
 		  sccb_stop: if(ack==2'b11) begin //stop
 							stop=1;
 							sccb_state_d=sccb_idle;
 							led_d=4'b1001;
 						 end
 			 default: sccb_state_d=wait_init;
 		endcase
 		
 	 end
 	 
 
 	 assign cmos_pwdn=0; //fixed at ground
 	 assign cmos_rst_n=1; //fixed at high
 	 
 	 assign led=led_q; //debugging LED , non-red LED if no problem
 	 
 	 always @(posedge clk_100) begin
     	 key0_prev<=key0;
     	 key1_prev<=key1;
     	 key2_prev<=key2;
     	 key3_prev<=key3;
     	 
     	 key0_tick=!key0_prev && key0;
     	 key1_tick=!key1_prev && key1;
     	 key2_tick=!key2_prev && key2;
     	 key3_tick=!key3_prev && key3;
 	 end
 	 
endmodule
//---- Top entity
module vcfd9ba (
 input v444878,
 input v6a82dd,
 output vd4e5d7
);
 wire w0;
 wire w1;
 wire w2;
 assign vd4e5d7 = w0;
 assign w1 = v444878;
 assign w2 = v6a82dd;
 vcfd9ba_va7041c va7041c (
  .out(w0),
  .clk(w1),
  .in(w2)
 );
endmodule

//---------------------------------------------------
//-- Debouncer
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Remove the rebound on a mechanical switch
//---------------------------------------------------

module vcfd9ba_va7041c (
 input clk,
 input in,
 output out
);
 //-- Debouncer Circuit
 //-- It produces a stable output when the
 //-- input signal is bouncing
 
 reg btn_prev = 0;
 reg btn_out_r = 0;
 
 reg [16:0] counter = 0;
 
 
 always @(posedge clk) begin
 
   //-- If btn_prev and btn_in are differents
   if (btn_prev ^ in == 1'b1) begin
     
       //-- Reset the counter
       counter <= 0;
       
       //-- Capture the button status
       btn_prev <= in;
   end
     
   //-- If no timeout, increase the counter
   else if (counter[16] == 1'b0)
       counter <= counter + 1;
       
   else
     //-- Set the output to the stable value
     btn_out_r <= btn_prev;
 
 end
 
 assign out = btn_out_r;
 
endmodule
//---- Top entity
module v96ca63 #(
 parameter vfa830d = 100000000,
 parameter v882d22 = 100000,
 parameter v64365f = 2
) (
 input v6ead63,
 input vd0348a,
 input v63e08d,
 input ve9b86c,
 input [7:0] vc4be01,
 output v204c37,
 output [1:0] va203ef,
 output [7:0] v401ec0,
 output [3:0] v967217,
 output vb03459,
 output v6a1f4c
);
 localparam p10 = vfa830d;
 localparam p11 = v882d22;
 localparam p12 = v64365f;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:7] w4;
 wire w5;
 wire [0:3] w6;
 wire [0:7] w7;
 wire [0:1] w8;
 wire w9;
 wire w13;
 assign w0 = v6ead63;
 assign w1 = vd0348a;
 assign w2 = v63e08d;
 assign w3 = ve9b86c;
 assign w4 = vc4be01;
 assign v204c37 = w5;
 assign v967217 = w6;
 assign v401ec0 = w7;
 assign va203ef = w8;
 assign vb03459 = w9;
 assign v6a1f4c = w13;
 v96ca63_vb70907 #(
  .main_clock(p10),
  .freq(p11),
  .addr_bytes(p12)
 ) vb70907 (
  .clk(w0),
  .rst_n(w1),
  .start(w2),
  .stop(w3),
  .wr_data(w4),
  .rd_tick(w5),
  .state(w6),
  .rd_data(w7),
  .ack(w8),
  .scl(w9),
  .sda(w13)
 );
endmodule

//---------------------------------------------------
//-- i2c
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- i2c for camera configuration
//---------------------------------------------------

module v96ca63_vb70907 #(
 parameter main_clock = 0,
 parameter freq = 0,
 parameter addr_bytes = 0
) (
 input clk,
 input rst_n,
 input start,
 input stop,
 input [7:0] wr_data,
 output rd_tick,
 output [1:0] ack,
 output [7:0] rd_data,
 output [3:0] state,
 output scl,
 output sda
);
 	 localparam full= (main_clock)/(2*freq),
 					half= full/2,
 					counter_width=log2(full);
 					
 	 function integer log2(input integer n); //automatically determines the width needed by counter
 		integer i;
 		 begin
 			log2=1;
 			for(i=0;2**i<n;i=i+1)
 				log2=i+1;
 		 end
 	 endfunction
 		 
 	 //FSM state declarations
 	 localparam[3:0] 		idle=0,
 							starting=1,
 							packet=2,
 							ack_servant=3,
 							read=4,
 							ack_master=5,
 							stop_1=6,
 							stop_2=7;
 	 reg[3:0] state_q=idle,state_d;
 	 reg op_q=0,op_d;
 	 reg[3:0] idx_q=0,idx_d;
 	 reg[8:0] wr_data_q=0,wr_data_d;
 	 reg[7:0] rd_data_q,rd_data_d;
 	 reg scl_q=0,scl_d;
 	 reg sda_q=0,sda_d;
 	 reg[counter_width-1:0] counter_q=0,counter_d;
 	 reg[1:0] addr_bytes_q=0,addr_bytes_d;
 	 wire scl_lo,scl_hi;
 	 wire sda_in;
 	 reg rd_tick;
 	 reg[1:0] ack;
 	//register operations
 	 always@(posedge clk, negedge rst_n) begin
 		if(!rst_n) begin
 			state_q<=idle;
 			idx_q<=0;
 			wr_data_q<=0;
 			scl_q<=0;
 			sda_q<=0;
 			counter_q<=0;
 			rd_data_q<=0;
 			addr_bytes_q<=0;
 		end
 		else begin
 			state_q<=state_d;
 			op_q<=op_d;
 			idx_q<=idx_d;
 			wr_data_q<=wr_data_d;
 			scl_q<=scl_d;
 			sda_q<=sda_d;
 			counter_q<=counter_d;
 			rd_data_q<=rd_data_d;
 			addr_bytes_q<=addr_bytes_d;
 		end
 	 end
 	 
 	 
 	 //free-running clk, freq depends on parameter "freq"
 	 always @* begin
 		counter_d=counter_q+1;
 		scl_d=scl_q;
 		if(state_q==idle || state_q==starting) scl_d=1'b1;
 		else if(counter_q==full) begin
 			counter_d=0;
 			scl_d=(scl_q==0)?1'b1:1'b0;
 		end
 	 end
 	 
 	 
 	 //FSM next-state logic
 	 always @* begin
 		state_d=state_q;
 		op_d=op_q;
 		idx_d=idx_q;
 		wr_data_d=wr_data_q;
 		rd_data_d=rd_data_q;
 		addr_bytes_d=addr_bytes_q;
 		sda_d=sda_q;
 		ack=0;
 		rd_tick=0;
 		
 		case(state_q)
 					idle: begin		//wait for the "start" to assert
 								sda_d=1'b1;
 								addr_bytes_d=addr_bytes; 
 								if(start==1'b1) begin
 									wr_data_d={wr_data,1'b1}; //the last 1'b1 is for the ACK coming from the servant("1" means high impedance or "reading")
 									op_d= (wr_data[0])? 1:0; // if last bit(R/W bit) is one:read operation, else write operation
 									idx_d=8; //index to be used on transmitting the wr_data serially(MSB first)
 									state_d=starting;
 								end
 							 end
 							 
 				starting: if(scl_hi) begin //start command, change sda to low while scl is high
 								sda_d=0;
 								state_d=packet;
 							 end
 							 
 				  packet: if(scl_lo) begin //transmit wr_data serially(MSB first)
 								sda_d= (wr_data_q[idx_q]==0)? 0:1'b1;
 								idx_d= idx_q-1;
 								if(idx_q==0) begin
 									state_d=ack_servant;
 									idx_d=0;
 								end
 							 end
   							 
 			ack_servant: if(scl_hi) begin //wait for ACK bit response(9th bit) from servant
 								ack[1]=1;
 								ack[0]=!sda_in; 
 								wr_data_d={wr_data,1'b1}; //after acknowledge tick, master must have already have the next data it wants to give
 								addr_bytes_d=addr_bytes_q-1;
 								if(stop) state_d=stop_1; //master can forcefully stops the transaction(even if response is either NACK or ACK)
 								else if(op_q && addr_bytes_q==0) begin //start reading after writing addr_bytes of packets for address
 									idx_d=7;
 									state_d=read;
 								end
 								else begin //write next packet
 									idx_d=8;
 									state_d=packet; 
 								end
 							 end
 							 
 					 read: if(scl_hi) begin //read data from slave(MSB first)
 								rd_data_d[idx_q]=sda_in;
 								idx_d=idx_q-1;
 								if(idx_q==0) state_d=ack_master;
 							 end
 							 
 			 ack_master: if(scl_lo) begin //master must ACK after receiving data from servant
 								sda_d=1'b0; 
 								if(sda_q==0) begin //one whole bit(two scl_lo) had passed
 									rd_tick=1;
 									idx_d=7;
 									if(stop) state_d=stop_1; //after receiving data, master can opt to stop
 									else state_d=read; ///after receiving data, master can also just continue receving more data
 								end
 							 end
 				  stop_1: if(scl_lo) begin
 								sda_d=1'b0;
 								state_d=stop_2;
 							 end
 				  stop_2: if(scl_hi) begin
 								sda_d=1'b1;
 								state_d=idle;
 							 end
 				 default: state_d=idle;
 		endcase
 	 end
 	 
 	 /*
 	 //i2c output logic
 	 assign scl=scl_q? 1'bz:0; //bidiectional logic for pull-up scl
 	 assign sda=sda_q? 1'bz:0; //bidirectional logic for pull-up scl
 	 assign sda_in=sda;
 	 */
 	 
 	 //sccb output logic
 	 wire temp;
 	 assign scl=scl_q; //sccb scl does not need pull-up
 	 assign temp=(state_q==read || state_q==ack_servant);
 	 //assign sda=(state_q==read || state_q==ack_servant)? 1'bz : sda_q; //sccb sda does not need pull-up
 	 //assign sda_in=sda;
 	 
 	 TRELLIS_IO #(.DIR("BIDIR")) tristate	 (
 	  .B(sda),
 	  .I(sda_q),
 	  .T(temp),
 	  .O(sda_in)
 	 );
 	 
 	 assign scl_hi= scl_q==1'b1 && counter_q==half && scl==1'b1; //scl is on the middle of a high(1) bit
 	 assign scl_lo= scl_q==1'b0 && counter_q==half; //scl is on the middle of a low(0) bit
 	 assign rd_data=rd_data_q;
 	 assign state=state_q;
endmodule
//---- Top entity
module v0644e6 (
 input v154578,
 input vc312eb,
 input v14fb5c,
 input vbecff9,
 input v88873d,
 input [16:0] v9cc419,
 output v9fff91,
 output v01607e,
 output [10:0] v8ceb21,
 output [10:0] vffb9ca,
 output [16:0] v6cc6df
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire [0:10] w10;
 wire [0:10] w11;
 wire [0:9] w12;
 wire [0:9] w13;
 wire [0:16] w14;
 wire [0:16] w15;
 assign w1 = v154578;
 assign w2 = vc312eb;
 assign w3 = v14fb5c;
 assign w4 = vbecff9;
 assign w5 = v88873d;
 assign w6 = vc312eb;
 assign w7 = v14fb5c;
 assign v9fff91 = w8;
 assign v01607e = w9;
 assign v8ceb21 = w10;
 assign vffb9ca = w11;
 assign w14 = v9cc419;
 assign v6cc6df = w15;
 assign w6 = w2;
 assign w7 = w3;
 v0644e6_v65c4d4 v65c4d4 (
  .we(w0),
  .rst_n(w1),
  .clk_write(w2),
  .clk_read(w3),
  .write(w4),
  .read(w5),
  .full(w8),
  .empty(w9),
  .data_count_w(w10),
  .data_count_r(w11),
  .w_ptr(w12),
  .r_ptr(w13)
 );
 vaa4bf2 vac59aa (
  .va43ab9(w0),
  .ve163d2(w6),
  .vf6ac69(w7),
  .vf3d037(w12),
  .v7583c7(w13),
  .v04a55b(w14),
  .vd39cfd(w15)
 );
endmodule

//---------------------------------------------------
//-- asyn_fifo
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- fifo with different read/write clock domains
//---------------------------------------------------

module v0644e6_v65c4d4 (
 input rst_n,
 input clk_write,
 input clk_read,
 input write,
 input read,
 output full,
 output empty,
 output [10:0] data_count_w,
 output [10:0] data_count_r,
 output we,
 output [9:0] w_ptr,
 output [9:0] r_ptr
);
  	 localparam DATA_WIDTH=17,
 	            FIFO_DEPTH_WIDTH=10,
 	            FIFO_DEPTH=2**FIFO_DEPTH_WIDTH;
 	 
 	 initial begin
 		full=0;
 		empty=1;
 	 end
 	 
 	 reg full, empty;
 	 reg[10:0] data_count_r,data_count_w;
 	 
 	 ///////////////////WRITE CLOCK DOMAIN//////////////////////////////
 	 reg[FIFO_DEPTH_WIDTH:0] w_ptr_q=0; //binary counter for write pointer
 	 reg[FIFO_DEPTH_WIDTH:0] r_ptr_sync; //binary pointer for read pointer sync to write clk
 	 wire[FIFO_DEPTH_WIDTH:0] w_grey,w_grey_nxt; //grey counter for write pointer
 	 reg[FIFO_DEPTH_WIDTH:0] r_grey_sync; //grey counter for the read pointer synchronized to write clock
 	 
 	 reg[3:0] i; //log_2(FIFO_DEPTH_WIDTH)
 	 
 	 assign w_grey=w_ptr_q^(w_ptr_q>>1); //binary to grey code conversion for current write pointer
 	 assign w_grey_nxt=(w_ptr_q+1'b1)^((w_ptr_q+1'b1)>>1);  //next grey code
 	 assign we= write && !full; 
 	 
 	 //register operation
 	 always @(posedge clk_write,negedge rst_n) begin
 		if(!rst_n) begin
 			w_ptr_q<=0;
 			full<=0;
 		end
 		else begin
 			if(write && !full) begin //write condition
 				w_ptr_q<=w_ptr_q+1'b1; 
 				full <= w_grey_nxt == {~r_grey_sync[FIFO_DEPTH_WIDTH:FIFO_DEPTH_WIDTH-1],r_grey_sync[FIFO_DEPTH_WIDTH-2:0]}; //algorithm for full logic which can be observed on the grey code table
 			end
 			else full <= w_grey == {~r_grey_sync[FIFO_DEPTH_WIDTH:FIFO_DEPTH_WIDTH-1],r_grey_sync[FIFO_DEPTH_WIDTH-2:0]}; 
 			
 			for(i=0;i<=FIFO_DEPTH_WIDTH;i=i+1) r_ptr_sync[i]=^(r_grey_sync>>i); //grey code to binary converter 
 			data_count_w <= (w_ptr_q>=r_ptr_sync)? (w_ptr_q-r_ptr_sync):(FIFO_DEPTH-r_ptr_sync+w_ptr_q); //compares write pointer and sync read pointer to generate data_count
 		end							
 	 end
 
 	/////////////////////////////////////////////////////////////////////
 	 
 	 
 	  ///////////////////READ CLOCK DOMAIN//////////////////////////////
 	 reg[FIFO_DEPTH_WIDTH:0] r_ptr_q=0; //binary counter for read pointer
 	 wire[FIFO_DEPTH_WIDTH:0] r_ptr_d;
 	 reg[FIFO_DEPTH_WIDTH:0] w_ptr_sync; //binary counter for write pointer sync to read clk
 	 reg[FIFO_DEPTH_WIDTH:0] w_grey_sync; //grey counter for the write pointer synchronized to read clock
 	 wire[FIFO_DEPTH_WIDTH:0] r_grey,r_grey_nxt; //grey counter for read pointer 
 	 
 	 
 	 assign r_grey= r_ptr_q^(r_ptr_q>>1);  //binary to grey code conversion
 	 assign r_grey_nxt= (r_ptr_q+1'b1)^((r_ptr_q+1'b1)>>1); //next grey code
 	 assign r_ptr_d= (read && !empty)? r_ptr_q+1'b1:r_ptr_q;
 	 
 	 //register operation
 	 always @(posedge clk_read,negedge rst_n) begin
 		if(!rst_n) begin
 			r_ptr_q<=0;
 			empty<=1;
 		end
 		else begin
 			r_ptr_q<=r_ptr_d;
 			if(read && !empty) empty <= r_grey_nxt==w_grey_sync;//empty condition
 			else empty <= r_grey==w_grey_sync; 
 			
 			for(i=0;i<=FIFO_DEPTH_WIDTH;i=i+1) w_ptr_sync[i]=^(w_grey_sync>>i); //grey code to binary converter
 			data_count_r = (w_ptr_q>=r_ptr_sync)? (w_ptr_q-r_ptr_sync):(FIFO_DEPTH-r_ptr_sync+w_ptr_q); //compares read pointer to sync write pointer to generate data_count
 		end
 	 end
 	 ////////////////////////////////////////////////////////////////////////
 	 
 	 
 	 /////////////////////CLOCK DOMAIN CROSSING//////////////////////////////
 	 reg[FIFO_DEPTH_WIDTH:0] r_grey_sync_temp;
 	 reg[FIFO_DEPTH_WIDTH:0] w_grey_sync_temp;
 	 always @(posedge clk_write) begin //2 D-Flipflops for reduced metastability in clock domain crossing from READ DOMAIN to WRITE DOMAIN
 		r_grey_sync_temp<=r_grey; 
 		r_grey_sync<=r_grey_sync_temp;
 	 end
 	 always @(posedge clk_read) begin //2 D-Flipflops for reduced metastability in clock domain crossing from WRITE DOMAIN to READ DOMAIN
 		w_grey_sync_temp<=w_grey;
 		w_grey_sync<=w_grey_sync_temp;
 	 end
 	 
 	//////////////////////////////////////////////////////////////////////////
 	
 	assign w_ptr=w_ptr_q[9:0];
 	assign r_ptr=r_ptr_d[9:0];
 	 
 	 
 	 
endmodule
//---- Top entity
module vaa4bf2 (
 input vf6ac69,
 input ve163d2,
 input va43ab9,
 input [16:0] v04a55b,
 input [9:0] vf3d037,
 input [9:0] v7583c7,
 output [16:0] vd39cfd
);
 wire w0;
 wire w1;
 wire w2;
 wire [0:16] w3;
 wire [0:9] w4;
 wire [0:9] w5;
 wire [0:16] w6;
 assign w0 = vf6ac69;
 assign w1 = ve163d2;
 assign w2 = va43ab9;
 assign w3 = v04a55b;
 assign w4 = vf3d037;
 assign w5 = v7583c7;
 assign vd39cfd = w6;
 vaa4bf2_v21516f v21516f (
  .clk_r(w0),
  .clk_w(w1),
  .we(w2),
  .din(w3),
  .addr_a(w4),
  .addr_b(w5),
  .dout(w6)
 );
endmodule

//---------------------------------------------------
//-- dual_port_ram
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- uses block ram with separate read/write clock
//---------------------------------------------------

module vaa4bf2_v21516f (
 input clk_r,
 input clk_w,
 input we,
 input [16:0] din,
 input [9:0] addr_a,
 input [9:0] addr_b,
 output [16:0] dout
);
 	localparam ADDR_WIDTH=10,
 	               DATA_WIDTH=17;
 	
 	reg[DATA_WIDTH-1:0] ram[2**ADDR_WIDTH-1:0];
 	reg[ADDR_WIDTH-1:0] addr_b_q;
 	
 	always @(posedge clk_w) begin
 		if(we) ram[addr_a]<=din;
 	end
 	always @(posedge clk_r) begin
 		addr_b_q<=addr_b;	
 	end
 	assign dout=ram[addr_b_q];
endmodule
//---- Top entity
module ve6a150 (
 input v154578,
 input vc312eb,
 input v14fb5c,
 input vbecff9,
 input v88873d,
 input [16:0] v9cc419,
 output v9fff91,
 output v01607e,
 output [10:0] v8ceb21,
 output [10:0] vffb9ca,
 output [16:0] v6cc6df
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire [0:10] w10;
 wire [0:10] w11;
 wire [0:16] w12;
 wire [0:16] w13;
 wire [0:10] w14;
 wire [0:10] w15;
 assign w1 = v154578;
 assign w2 = vc312eb;
 assign w3 = v14fb5c;
 assign w4 = vbecff9;
 assign w5 = v88873d;
 assign w6 = vc312eb;
 assign w7 = v14fb5c;
 assign v9fff91 = w8;
 assign v01607e = w9;
 assign v8ceb21 = w10;
 assign vffb9ca = w11;
 assign w12 = v9cc419;
 assign v6cc6df = w13;
 assign w6 = w2;
 assign w7 = w3;
 ve6a150_v65c4d4 v65c4d4 (
  .we(w0),
  .rst_n(w1),
  .clk_write(w2),
  .clk_read(w3),
  .write(w4),
  .read(w5),
  .full(w8),
  .empty(w9),
  .data_count_w(w10),
  .data_count_r(w11),
  .w_ptr(w14),
  .r_ptr(w15)
 );
 va3bd66 veb779c (
  .va43ab9(w0),
  .ve163d2(w6),
  .vf6ac69(w7),
  .v04a55b(w12),
  .vd39cfd(w13),
  .v1f4254(w14),
  .v373679(w15)
 );
endmodule

//---------------------------------------------------
//-- asyn_fifo
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- fifo with different read/write clock domains
//---------------------------------------------------

module ve6a150_v65c4d4 (
 input rst_n,
 input clk_write,
 input clk_read,
 input write,
 input read,
 output full,
 output empty,
 output [10:0] data_count_w,
 output [10:0] data_count_r,
 output we,
 output [10:0] w_ptr,
 output [10:0] r_ptr
);
  	 localparam DATA_WIDTH=17,
 	            FIFO_DEPTH_WIDTH=11,
 	            FIFO_DEPTH=2**FIFO_DEPTH_WIDTH;
 	 
 	 initial begin
 		full=0;
 		empty=1;
 	 end
 	 
 	 reg full, empty;
 	 reg[10:0] data_count_r,data_count_w;
 	 
 	 ///////////////////WRITE CLOCK DOMAIN//////////////////////////////
 	 reg[FIFO_DEPTH_WIDTH:0] w_ptr_q=0; //binary counter for write pointer
 	 reg[FIFO_DEPTH_WIDTH:0] r_ptr_sync; //binary pointer for read pointer sync to write clk
 	 wire[FIFO_DEPTH_WIDTH:0] w_grey,w_grey_nxt; //grey counter for write pointer
 	 reg[FIFO_DEPTH_WIDTH:0] r_grey_sync; //grey counter for the read pointer synchronized to write clock
 	 
 	 reg[3:0] i; //log_2(FIFO_DEPTH_WIDTH)
 	 
 	 assign w_grey=w_ptr_q^(w_ptr_q>>1); //binary to grey code conversion for current write pointer
 	 assign w_grey_nxt=(w_ptr_q+1'b1)^((w_ptr_q+1'b1)>>1);  //next grey code
 	 assign we= write && !full; 
 	 
 	 //register operation
 	 always @(posedge clk_write,negedge rst_n) begin
 		if(!rst_n) begin
 			w_ptr_q<=0;
 			full<=0;
 		end
 		else begin
 			if(write && !full) begin //write condition
 				w_ptr_q<=w_ptr_q+1'b1; 
 				full <= w_grey_nxt == {~r_grey_sync[FIFO_DEPTH_WIDTH:FIFO_DEPTH_WIDTH-1],r_grey_sync[FIFO_DEPTH_WIDTH-2:0]}; //algorithm for full logic which can be observed on the grey code table
 			end
 			else full <= w_grey == {~r_grey_sync[FIFO_DEPTH_WIDTH:FIFO_DEPTH_WIDTH-1],r_grey_sync[FIFO_DEPTH_WIDTH-2:0]}; 
 			
 			for(i=0;i<=FIFO_DEPTH_WIDTH;i=i+1) r_ptr_sync[i]=^(r_grey_sync>>i); //grey code to binary converter 
 			data_count_w <= (w_ptr_q>=r_ptr_sync)? (w_ptr_q-r_ptr_sync):(FIFO_DEPTH-r_ptr_sync+w_ptr_q); //compares write pointer and sync read pointer to generate data_count
 		end							
 	 end
 
 	/////////////////////////////////////////////////////////////////////
 	 
 	 
 	  ///////////////////READ CLOCK DOMAIN//////////////////////////////
 	 reg[FIFO_DEPTH_WIDTH:0] r_ptr_q=0; //binary counter for read pointer
 	 wire[FIFO_DEPTH_WIDTH:0] r_ptr_d;
 	 reg[FIFO_DEPTH_WIDTH:0] w_ptr_sync; //binary counter for write pointer sync to read clk
 	 reg[FIFO_DEPTH_WIDTH:0] w_grey_sync; //grey counter for the write pointer synchronized to read clock
 	 wire[FIFO_DEPTH_WIDTH:0] r_grey,r_grey_nxt; //grey counter for read pointer 
 	 
 	 
 	 assign r_grey= r_ptr_q^(r_ptr_q>>1);  //binary to grey code conversion
 	 assign r_grey_nxt= (r_ptr_q+1'b1)^((r_ptr_q+1'b1)>>1); //next grey code
 	 assign r_ptr_d= (read && !empty)? r_ptr_q+1'b1:r_ptr_q;
 	 
 	 //register operation
 	 always @(posedge clk_read,negedge rst_n) begin
 		if(!rst_n) begin
 			r_ptr_q<=0;
 			empty<=1;
 		end
 		else begin
 			r_ptr_q<=r_ptr_d;
 			if(read && !empty) empty <= r_grey_nxt==w_grey_sync;//empty condition
 			else empty <= r_grey==w_grey_sync; 
 			
 			for(i=0;i<=FIFO_DEPTH_WIDTH;i=i+1) w_ptr_sync[i]=^(w_grey_sync>>i); //grey code to binary converter
 			data_count_r = (w_ptr_q>=r_ptr_sync)? (w_ptr_q-r_ptr_sync):(FIFO_DEPTH-r_ptr_sync+w_ptr_q); //compares read pointer to sync write pointer to generate data_count
 		end
 	 end
 	 ////////////////////////////////////////////////////////////////////////
 	 
 	 
 	 /////////////////////CLOCK DOMAIN CROSSING//////////////////////////////
 	 reg[FIFO_DEPTH_WIDTH:0] r_grey_sync_temp;
 	 reg[FIFO_DEPTH_WIDTH:0] w_grey_sync_temp;
 	 always @(posedge clk_write) begin //2 D-Flipflops for reduced metastability in clock domain crossing from READ DOMAIN to WRITE DOMAIN
 		r_grey_sync_temp<=r_grey; 
 		r_grey_sync<=r_grey_sync_temp;
 	 end
 	 always @(posedge clk_read) begin //2 D-Flipflops for reduced metastability in clock domain crossing from WRITE DOMAIN to READ DOMAIN
 		w_grey_sync_temp<=w_grey;
 		w_grey_sync<=w_grey_sync_temp;
 	 end
 	 
 	//////////////////////////////////////////////////////////////////////////
 	
 	assign w_ptr=w_ptr_q[10:0];
 	assign r_ptr=r_ptr_d[10:0];
 	 
 	 
 	 
endmodule
//---- Top entity
module va3bd66 (
 input vf6ac69,
 input ve163d2,
 input va43ab9,
 input [16:0] v04a55b,
 input [10:0] v1f4254,
 input [10:0] v373679,
 output [16:0] vd39cfd
);
 wire w0;
 wire w1;
 wire w2;
 wire [0:16] w3;
 wire [0:16] w4;
 wire [0:10] w5;
 wire [0:10] w6;
 assign w0 = vf6ac69;
 assign w1 = ve163d2;
 assign w2 = va43ab9;
 assign w3 = v04a55b;
 assign vd39cfd = w4;
 assign w5 = v1f4254;
 assign w6 = v373679;
 va3bd66_v21516f v21516f (
  .clk_r(w0),
  .clk_w(w1),
  .we(w2),
  .din(w3),
  .dout(w4),
  .addr_a(w5),
  .addr_b(w6)
 );
endmodule

//---------------------------------------------------
//-- dual_port_ram
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- uses block ram with separate read/write clock
//---------------------------------------------------

module va3bd66_v21516f (
 input clk_r,
 input clk_w,
 input we,
 input [16:0] din,
 input [10:0] addr_a,
 input [10:0] addr_b,
 output [16:0] dout
);
 	localparam ADDR_WIDTH=11,
 	               DATA_WIDTH=17;
 	
 	reg[DATA_WIDTH-1:0] ram[2**ADDR_WIDTH-1:0];
 	reg[ADDR_WIDTH-1:0] addr_b_q;
 	
 	always @(posedge clk_w) begin
 		if(we) ram[addr_a]<=din;
 	end
 	always @(posedge clk_r) begin
 		addr_b_q<=addr_b;	
 	end
 	assign dout=ram[addr_b_q];
endmodule
//---- Top entity
module v2b8124 (
 input vef4a17,
 input v1f84c3,
 input v78b3e5,
 input [8:0] vb68f1b,
 input [10:0] v047d0f,
 input [10:0] v3aa53b,
 input [16:0] ve6ca0d,
 input v8284ba,
 input v966dc3,
 output v826765,
 output vf84337,
 output v8017c3,
 output ve90166,
 output v917e66,
 output v7699e6,
 output va88c3b,
 output [12:0] v2a425f,
 output [1:0] v4de55f,
 output [1:0] v140121,
 output [15:0] vce2330,
 output v90eda9,
 output v831e9c,
 output [15:0] v1417c5
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire [0:15] w8;
 wire [0:15] w9;
 wire w10;
 wire [0:10] w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 wire [0:1] w23;
 wire [0:15] w24;
 wire [0:1] w25;
 wire [0:10] w26;
 wire [0:12] w27;
 wire w28;
 wire w29;
 wire [0:14] w30;
 wire [0:15] w31;
 wire w32;
 wire [0:10] w33;
 wire [0:8] w34;
 wire [0:16] w35;
 assign w0 = vef4a17;
 assign w1 = v1f84c3;
 assign w2 = vef4a17;
 assign w3 = v1f84c3;
 assign w4 = v1f84c3;
 assign w5 = v8284ba;
 assign w6 = vef4a17;
 assign v1417c5 = w9;
 assign v831e9c = w10;
 assign v826765 = w14;
 assign w16 = v966dc3;
 assign vf84337 = w17;
 assign v8017c3 = w18;
 assign ve90166 = w19;
 assign v917e66 = w20;
 assign v7699e6 = w21;
 assign va88c3b = w22;
 assign v4de55f = w23;
 assign vce2330 = w24;
 assign v140121 = w25;
 assign w26 = v3aa53b;
 assign v2a425f = w27;
 assign w29 = v78b3e5;
 assign v90eda9 = w32;
 assign w33 = v047d0f;
 assign w34 = vb68f1b;
 assign w35 = ve6ca0d;
 assign w2 = w0;
 assign w3 = w1;
 assign w4 = w1;
 assign w4 = w3;
 assign w6 = w0;
 assign w6 = w2;
 vd907ee vb01cee (
  .v154578(w4),
  .v14fb5c(w5),
  .vc312eb(w6),
  .vbecff9(w7),
  .vb730c2(w8),
  .v947e96(w9),
  .v01607e(w10),
  .v8ceb21(w11),
  .v88873d(w16)
 );
 vfb7895 vbdbe11 (
  .vbe24c9(w2),
  .vdf2bc1(w3),
  .vbf18cc(w7),
  .v742eac(w8),
  .v4d9a75(w12),
  .v4c636b(w13),
  .vde3dc9(w15),
  .v1d370a(w17),
  .v6fa753(w18),
  .va889a6(w19),
  .vb4e6e9(w20),
  .v802779(w21),
  .v6c0920(w22),
  .v7a23d0(w23),
  .veb4698(w24),
  .v8e5ad1(w25),
  .va4660d(w27),
  .vc7b821(w28),
  .v9669f7(w30),
  .v8a3550(w31)
 );
 v2b8124_vd61c04 vd61c04 (
  .clk(w0),
  .rst_n(w1),
  .data_count_w(w11),
  .f2s_data_valid(w12),
  .rw(w13),
  .rd_camera(w14),
  .ready(w15),
  .data_count_camera_fifo(w26),
  .rw_en(w28),
  .sobel(w29),
  .f_addr(w30),
  .f2s_data(w31),
  .rd_sobel(w32),
  .data_count_r(w33),
  .sobel_data(w34),
  .din(w35)
 );
endmodule

//---------------------------------------------------
//-- sdram_interface
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- stores pixel data from camera then send data to HDMI
//---------------------------------------------------

module v2b8124_vd61c04 (
 input clk,
 input rst_n,
 input sobel,
 input [8:0] sobel_data,
 input [10:0] data_count_r,
 input [10:0] data_count_camera_fifo,
 input [16:0] din,
 input f2s_data_valid,
 input [10:0] data_count_w,
 input ready,
 output rd_camera,
 output rw,
 output rw_en,
 output [14:0] f_addr,
 output [15:0] f2s_data,
 output rd_sobel
);
  	 //FSM state declarations
  localparam idle=0,
 				burst_op=1;
 				
  reg state_q=0,state_d;	 
  reg[14:0] colored_addr_q=0,colored_addr_d,sobel_addr_q=0,sobel_addr_d;
  reg[14:0] rd_addr_q=0,rd_addr_d;
  reg rw,rw_en;
  reg orig_q=0,orig_d;
  reg[14:0] f_addr;
  reg[15:0] f2s_data;
  
  
  //register operation
  always @(posedge clk,negedge rst_n) begin
 	if(!rst_n) begin
 		state_q<=0;
 		colored_addr_q<=0;
 		rd_addr_q<=0;
 		orig_q<=0;
 		sobel_addr_q<=0;
 	end
 	else begin
 		state_q<=state_d;
 		colored_addr_q<=colored_addr_d;
 		rd_addr_q<=rd_addr_d;
 		orig_q<=orig_d;
 		sobel_addr_q<=sobel_addr_d;
 	end
  end
  
  //FSM next-state declarations
  always @* begin
 	state_d=state_q;
 	colored_addr_d=colored_addr_q;
 	rd_addr_d=rd_addr_q;
 	sobel_addr_d=sobel_addr_q;
 	f_addr=0;
 	rw=0;
 	rw_en=0;
 	orig_d=orig_q;
 	
 	case(state_q)
 		    idle: if(data_count_camera_fifo>512 && ready) begin //wait for the first 512 pixel-data to fill the asyn_fifo then burst-write it to sdram
 						rw_en=1;
 						rw=0;
 						sobel_addr_d=600;
 						colored_addr_d=1;
 						f_addr=colored_addr_q;
 						state_d=burst_op;
 						orig_d=1;
 					 end
 		burst_op: if(ready) begin //choose whether to read the colored image or edge detected image OR write to the fifo of VGA
 							if(data_count_camera_fifo>512) begin //colored image container is filled to 512 thus we can now burst-write(full-page has 512 data) it to SDRAM 
 								rw_en=1;
 								rw=0;
 								colored_addr_d=(colored_addr_q==599)? 0:colored_addr_q+1'b1; //One frame(640x480) fills the addresses 0-to-599
 								f_addr=colored_addr_q;
 								orig_d=1;
 							end
 							
 							else if(data_count_w<250) begin //asyn_fifo of VGA has only 250 pixel data left, we will now fill it by another 512 pixel data via burst reading the sdram
 								rw_en=1;
 								rw=1;
 								rd_addr_d=(rd_addr_q==599)? 0:rd_addr_q+1'b1;
 								f_addr= sobel? (rd_addr_q+600):rd_addr_q;
 							end
 							else if(data_count_r>500) begin //burst write the edge detected image to SDRAM
 								rw_en=1;
 								rw=0;
 								sobel_addr_d=(sobel_addr_q==1199)? 600:sobel_addr_q+1'b1;
 								f_addr=sobel_addr_q;
 								orig_d=0;
 							end
 					 end
 		 default: state_d=idle;
 	endcase
 	f2s_data= orig_d? (din[16]? 16'b00000_000000_11111:din[15:0]): {7'b000_0000,sobel_data};
 	                   //used as placeholder for first pixel for RGB
 	//debug
 	/*if(colored_addr_q<75) f2s_data={{5{1'b0}},{6{1'b0}},{5{1'b0}}};
 	else if(colored_addr_q<150) f2s_data={{5{1'b0}},{6{1'b0}},{5{1'b1}}};
 	else if(colored_addr_q<225) f2s_data={{5{1'b0}},{6{1'b1}},{5{1'b0}}};
 	else if(colored_addr_q<300) f2s_data={{5{1'b0}},{6{1'b1}},{5{1'b1}}};
 	else if(colored_addr_q<375) f2s_data={{5{1'b1}},{6{1'b0}},{5{1'b0}}};
 	else if(colored_addr_q<450) f2s_data={{5{1'b1}},{6{1'b0}},{5{1'b1}}};
 	else if(colored_addr_q<525) f2s_data={{5{1'b1}},{6{1'b1}},{5{1'b0}}};
 	else if(colored_addr_q<600) f2s_data={{5{1'b1}},{6{1'b1}},{5{1'b1}}};*/
  end
  
 
  assign rd_camera= f2s_data_valid && orig_d;
  assign rd_sobel= f2s_data_valid && !orig_d;
  
endmodule
//---- Top entity
module vd907ee (
 input v154578,
 input vc312eb,
 input v14fb5c,
 input vbecff9,
 input v88873d,
 input [15:0] vb730c2,
 output v9fff91,
 output v01607e,
 output [10:0] v8ceb21,
 output [10:0] vffb9ca,
 output [15:0] v947e96
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire [0:10] w10;
 wire [0:10] w11;
 wire [0:10] w12;
 wire [0:10] w13;
 wire [0:15] w14;
 wire [0:15] w15;
 assign w1 = v154578;
 assign w2 = vc312eb;
 assign w3 = v14fb5c;
 assign w4 = vbecff9;
 assign w5 = v88873d;
 assign w6 = vc312eb;
 assign w7 = v14fb5c;
 assign v9fff91 = w8;
 assign v01607e = w9;
 assign v8ceb21 = w10;
 assign vffb9ca = w11;
 assign w14 = vb730c2;
 assign v947e96 = w15;
 assign w6 = w2;
 assign w7 = w3;
 vd907ee_v65c4d4 v65c4d4 (
  .we(w0),
  .rst_n(w1),
  .clk_write(w2),
  .clk_read(w3),
  .write(w4),
  .read(w5),
  .full(w8),
  .empty(w9),
  .data_count_w(w10),
  .data_count_r(w11),
  .w_ptr(w12),
  .r_ptr(w13)
 );
 v1d9258 vebffa0 (
  .va43ab9(w0),
  .ve163d2(w6),
  .vf6ac69(w7),
  .v6d0616(w12),
  .v79bd3e(w13),
  .v63ce58(w14),
  .v63f4ed(w15)
 );
endmodule

//---------------------------------------------------
//-- asyn_fifo
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- fifo with different read/write clock domains
//---------------------------------------------------

module vd907ee_v65c4d4 (
 input rst_n,
 input clk_write,
 input clk_read,
 input write,
 input read,
 output full,
 output empty,
 output [10:0] data_count_w,
 output [10:0] data_count_r,
 output we,
 output [10:0] w_ptr,
 output [10:0] r_ptr
);
  	 localparam DATA_WIDTH=16,
 	            FIFO_DEPTH_WIDTH=11,
 	            FIFO_DEPTH=2**FIFO_DEPTH_WIDTH;
 	 
 	 initial begin
 		full=0;
 		empty=1;
 	 end
 	 
 	 reg full, empty;
 	 reg[10:0] data_count_r,data_count_w;
 	 
 	 ///////////////////WRITE CLOCK DOMAIN//////////////////////////////
 	 reg[FIFO_DEPTH_WIDTH:0] w_ptr_q=0; //binary counter for write pointer
 	 reg[FIFO_DEPTH_WIDTH:0] r_ptr_sync; //binary pointer for read pointer sync to write clk
 	 wire[FIFO_DEPTH_WIDTH:0] w_grey,w_grey_nxt; //grey counter for write pointer
 	 reg[FIFO_DEPTH_WIDTH:0] r_grey_sync; //grey counter for the read pointer synchronized to write clock
 	 
 	 reg[3:0] i; //log_2(FIFO_DEPTH_WIDTH)
 	 
 	 assign w_grey=w_ptr_q^(w_ptr_q>>1); //binary to grey code conversion for current write pointer
 	 assign w_grey_nxt=(w_ptr_q+1'b1)^((w_ptr_q+1'b1)>>1);  //next grey code
 	 assign we= write && !full; 
 	 
 	 //register operation
 	 always @(posedge clk_write,negedge rst_n) begin
 		if(!rst_n) begin
 			w_ptr_q<=0;
 			full<=0;
 		end
 		else begin
 			if(write && !full) begin //write condition
 				w_ptr_q<=w_ptr_q+1'b1; 
 				full <= w_grey_nxt == {~r_grey_sync[FIFO_DEPTH_WIDTH:FIFO_DEPTH_WIDTH-1],r_grey_sync[FIFO_DEPTH_WIDTH-2:0]}; //algorithm for full logic which can be observed on the grey code table
 			end
 			else full <= w_grey == {~r_grey_sync[FIFO_DEPTH_WIDTH:FIFO_DEPTH_WIDTH-1],r_grey_sync[FIFO_DEPTH_WIDTH-2:0]}; 
 			
 			for(i=0;i<=FIFO_DEPTH_WIDTH;i=i+1) r_ptr_sync[i]=^(r_grey_sync>>i); //grey code to binary converter 
 			data_count_w <= (w_ptr_q>=r_ptr_sync)? (w_ptr_q-r_ptr_sync):(FIFO_DEPTH-r_ptr_sync+w_ptr_q); //compares write pointer and sync read pointer to generate data_count
 		end							
 	 end
 
 	/////////////////////////////////////////////////////////////////////
 	 
 	 
 	  ///////////////////READ CLOCK DOMAIN//////////////////////////////
 	 reg[FIFO_DEPTH_WIDTH:0] r_ptr_q=0; //binary counter for read pointer
 	 wire[FIFO_DEPTH_WIDTH:0] r_ptr_d;
 	 reg[FIFO_DEPTH_WIDTH:0] w_ptr_sync; //binary counter for write pointer sync to read clk
 	 reg[FIFO_DEPTH_WIDTH:0] w_grey_sync; //grey counter for the write pointer synchronized to read clock
 	 wire[FIFO_DEPTH_WIDTH:0] r_grey,r_grey_nxt; //grey counter for read pointer 
 	 
 	 
 	 assign r_grey= r_ptr_q^(r_ptr_q>>1);  //binary to grey code conversion
 	 assign r_grey_nxt= (r_ptr_q+1'b1)^((r_ptr_q+1'b1)>>1); //next grey code
 	 assign r_ptr_d= (read && !empty)? r_ptr_q+1'b1:r_ptr_q;
 	 
 	 //register operation
 	 always @(posedge clk_read,negedge rst_n) begin
 		if(!rst_n) begin
 			r_ptr_q<=0;
 			empty<=1;
 		end
 		else begin
 			r_ptr_q<=r_ptr_d;
 			if(read && !empty) empty <= r_grey_nxt==w_grey_sync;//empty condition
 			else empty <= r_grey==w_grey_sync; 
 			
 			for(i=0;i<=FIFO_DEPTH_WIDTH;i=i+1) w_ptr_sync[i]=^(w_grey_sync>>i); //grey code to binary converter
 			data_count_r = (w_ptr_q>=r_ptr_sync)? (w_ptr_q-r_ptr_sync):(FIFO_DEPTH-r_ptr_sync+w_ptr_q); //compares read pointer to sync write pointer to generate data_count
 		end
 	 end
 	 ////////////////////////////////////////////////////////////////////////
 	 
 	 
 	 /////////////////////CLOCK DOMAIN CROSSING//////////////////////////////
 	 reg[FIFO_DEPTH_WIDTH:0] r_grey_sync_temp;
 	 reg[FIFO_DEPTH_WIDTH:0] w_grey_sync_temp;
 	 always @(posedge clk_write) begin //2 D-Flipflops for reduced metastability in clock domain crossing from READ DOMAIN to WRITE DOMAIN
 		r_grey_sync_temp<=r_grey; 
 		r_grey_sync<=r_grey_sync_temp;
 	 end
 	 always @(posedge clk_read) begin //2 D-Flipflops for reduced metastability in clock domain crossing from WRITE DOMAIN to READ DOMAIN
 		w_grey_sync_temp<=w_grey;
 		w_grey_sync<=w_grey_sync_temp;
 	 end
 	 
 	//////////////////////////////////////////////////////////////////////////
 	
 	assign w_ptr=w_ptr_q[10:0];
 	assign r_ptr=r_ptr_d[10:0];
 	 
 	 
 	 
endmodule
//---- Top entity
module v1d9258 (
 input vf6ac69,
 input ve163d2,
 input va43ab9,
 input [15:0] v63ce58,
 input [10:0] v6d0616,
 input [10:0] v79bd3e,
 output [15:0] v63f4ed
);
 wire w0;
 wire w1;
 wire w2;
 wire [0:10] w3;
 wire [0:10] w4;
 wire [0:15] w5;
 wire [0:15] w6;
 assign w0 = vf6ac69;
 assign w1 = ve163d2;
 assign w2 = va43ab9;
 assign w3 = v6d0616;
 assign w4 = v79bd3e;
 assign w5 = v63ce58;
 assign v63f4ed = w6;
 v1d9258_v21516f v21516f (
  .clk_r(w0),
  .clk_w(w1),
  .we(w2),
  .addr_a(w3),
  .addr_b(w4),
  .din(w5),
  .dout(w6)
 );
endmodule

//---------------------------------------------------
//-- dual_port_ram
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- uses block ram with separate read/write clock
//---------------------------------------------------

module v1d9258_v21516f (
 input clk_r,
 input clk_w,
 input we,
 input [15:0] din,
 input [10:0] addr_a,
 input [10:0] addr_b,
 output [15:0] dout
);
 	localparam ADDR_WIDTH=11,
 	               DATA_WIDTH=16;
 	
 	reg[DATA_WIDTH-1:0] ram[2**ADDR_WIDTH-1:0];
 	reg[ADDR_WIDTH-1:0] addr_b_q;
 	
 	always @(posedge clk_w) begin
 		if(we) ram[addr_a]<=din;
 	end
 	always @(posedge clk_r) begin
 		addr_b_q<=addr_b;	
 	end
 	assign dout=ram[addr_b_q];
endmodule
//---- Top entity
module vfb7895 (
 input vbe24c9,
 input vdf2bc1,
 input v4c636b,
 input vc7b821,
 input [14:0] v9669f7,
 input [15:0] v8a3550,
 output [15:0] v742eac,
 output vbf18cc,
 output v4d9a75,
 output vde3dc9,
 output v1d370a,
 output v6fa753,
 output va889a6,
 output vb4e6e9,
 output v802779,
 output v6c0920,
 output [12:0] va4660d,
 output [1:0] v7a23d0,
 output [1:0] v8e5ad1,
 output [15:0] veb4698
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:14] w4;
 wire [0:15] w5;
 wire [0:15] w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire [0:12] w16;
 wire [0:1] w17;
 wire [0:15] w18;
 wire [0:1] w19;
 assign w0 = vdf2bc1;
 assign w1 = vbe24c9;
 assign w2 = v4c636b;
 assign w3 = vc7b821;
 assign w4 = v9669f7;
 assign w5 = v8a3550;
 assign v742eac = w6;
 assign vbf18cc = w7;
 assign v4d9a75 = w8;
 assign vde3dc9 = w9;
 assign v1d370a = w10;
 assign v6fa753 = w11;
 assign va889a6 = w12;
 assign vb4e6e9 = w13;
 assign v802779 = w14;
 assign v6c0920 = w15;
 assign va4660d = w16;
 assign v7a23d0 = w17;
 assign veb4698 = w18;
 assign v8e5ad1 = w19;
 vfb7895_vf775c2 vf775c2 (
  .rst_n(w0),
  .clk(w1),
  .rw(w2),
  .rw_en(w3),
  .f_addr(w4),
  .f2s_data(w5),
  .s2f_data(w6),
  .s2f_data_valid(w7),
  .f2s_data_valid(w8),
  .ready(w9),
  .s_clk(w10),
  .s_cke(w11),
  .s_cs_n(w12),
  .s_ras_n(w13),
  .s_cas_n(w14),
  .s_we_n(w15),
  .s_addr(w16),
  .s_ba(w17),
  .s_dq(w18),
  .s_dqm(w19)
 );
endmodule

//---------------------------------------------------
//-- sdram,_controller
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- SDRAM single-data rate controller 
//---------------------------------------------------

module vfb7895_vf775c2 (
 input clk,
 input rst_n,
 input rw,
 input rw_en,
 input [14:0] f_addr,
 input [15:0] f2s_data,
 output [15:0] s2f_data,
 output s2f_data_valid,
 output f2s_data_valid,
 output ready,
 output s_clk,
 output s_cke,
 output s_cs_n,
 output s_ras_n,
 output s_cas_n,
 output s_we_n,
 output [12:0] s_addr,
 output [1:0] s_ba,
 output [1:0] s_dqm,
 output [15:0] s_dq
);
 	 //s_clock(clk input to sdram) is 180 degrees lagging from main clock to solve the hold-setup time requirements of sdram
 	 ODDRX1F oddr_primitive
 	 (
 		.D0(1'b0), //1'b0
 		.D1(1'b1), //1'b1
 		.SCLK(clk),
 		.Q(s_clk)
 	);
 	//FSM states		//initialize
 	 localparam[3:0]  start=0,
 							precharge_init=1, 
 							refresh_1=2,
 							refresh_2=3,
 							load_mode_reg=4,
 							//normal operation
 							idle=5,
 							read=6,
 							read_data=7,
 							write=8,
 							write_burst=9,
 							//refresh every 7.81us
 							refresh=10,
 		
 							delay=11; //waiting state for any amount of delay needed
 							
 	//minimum time specs needed(in clks for 143MHz(7ns))
 	localparam[3:0] t_RP=2, //15ns(precharge) 
 					t_RC=9, //60ns(active to active,ref to ref) ///////////////
 					t_MRD=2, //2 clk,(mode register) /2/
 					t_RCD=2, //15ns (active to read/write)      ////////////
 					t_WR=2, //2clk delay after writing before manual/auto precharge can start
 					t_CL=3; //CAS latency(delay of data_out after read command)
 					
 	//commands {cs_n,ras_n,cas_n,we_n} REFER TO THE DATASHEET: winbond W9825G6KH
 	localparam[3:0]  cmd_precharge=4'b0010,
 						  cmd_NOP=4'b0111,
 						  cmd_activate=4'b0011,
 						  cmd_write=4'b0100,
 						  cmd_read=4'b0101,
 						  cmd_setmode=4'b0000,
 						  cmd_refresh=4'b0001;
 						  
 	reg[3:0] state_q,state_d; //_q is registered output, _d is input to DFF
 	reg[3:0] nxt_q,nxt_d; //state after next state
 	reg[3:0] cmd_q,cmd_d; //{cs_n,ras_n,cas_n,we_n}
 	reg[15:0] delay_ctr_q,delay_ctr_d; //stores delay needed(max is 200us for the initialization sequence)
 	reg[10:0] refresh_ctr_q=0,refresh_ctr_d; 
 	reg refresh_flag_q,refresh_flag_d;
 	reg[9:0] burst_index_q=0,burst_index_d; //stores the data left to be burst(512 for full page burst)
 	reg rw_d,rw_q,rw_en_q,rw_en_d;
 	
 	//buffer for output for a glitch-free signal
 	reg[12:0] s_addr_q,s_addr_d;
 	reg[1:0] s_ba_q,s_ba_d;
 	reg[15:0] s_dq_q,s_dq_d;
 	reg tri_q,tri_d;
 	
 	//buffer for input
 	reg[14:0] f_addr_q,f_addr_d;
 	reg[15:0] f2s_data_q,f2s_data_d;
 	reg[15:0] s2f_data_q,s2f_data_d;
 	reg s2f_data_valid_q,s2f_data_valid_d;
 
 	wire[15:0] s_dq_in;
 	wire LDQM,HDQM;
 	reg f2s_data_valid,ready;
 	
 	//register operation
 	always @(posedge clk,negedge rst_n) begin
 		if(!rst_n) begin
 			state_q<=start;
 			nxt_q<=start;
 			cmd_q<=cmd_NOP;
 			delay_ctr_q<=0;
 			refresh_ctr_q<=0;
 			s_addr_q<=0;
 			tri_q<=0;
 			rw_q<=0;
 			rw_en_q<=0;
 			
 			s_ba_q<=0;
 			s_dq_q<=0;
 			f_addr_q<=0;
 			rw_q<=0;
 			f2s_data_q<=0;
 			s2f_data_q<=0;
 			s2f_data_valid_q<=0;
 			rw_q<=0;
 			refresh_flag_q<=0;
 			burst_index_q<=0;
 		end
 		else begin
 			state_q<=state_d;
 			nxt_q<=nxt_d;
 			cmd_q<=cmd_d;
 			delay_ctr_q<=delay_ctr_d;
 			refresh_ctr_q<=refresh_ctr_d;
 			s_addr_q<=s_addr_d;
 			tri_q<=tri_d;
 			refresh_flag_q<=refresh_flag_d;
 			burst_index_q<=burst_index_d;
 			
 			s_ba_q<=s_ba_d;
 			s_dq_q<=s_dq_d;
 			f_addr_q<=f_addr_d;
 			rw_q<=rw_d;
 			f2s_data_q<=f2s_data_d;
 			s2f_data_q<=s2f_data_d;
 			s2f_data_valid_q<=s2f_data_valid_d;
 			rw_q<=rw_d;
 			rw_en_q<=rw_en_d;
 		end
 	end
 	
 
 	//next-state logics
 	always @* begin
 		state_d=state_q;
 		nxt_d=nxt_q;
 		cmd_d=cmd_NOP; //always default to No Operation 
 		delay_ctr_d=delay_ctr_q;
 		ready=0; 
 		s_addr_d=s_addr_q;
 		s_ba_d=s_ba_q;
 		s_dq_d=s_dq_q;
 		f_addr_d=f_addr_q;
 		rw_d=rw_q;
 		f2s_data_d=f2s_data_q;
 		s2f_data_d=s2f_data_q;
 		tri_d=0;  
 		s2f_data_valid_d=1'b0;
 		f2s_data_valid=1'b0;
 		burst_index_d=burst_index_q;
 		rw_d=rw_q;
 		rw_en_d=rw_en_q;
 		
 		//refresh every 7.8us or else data will be lost. 
 		refresh_flag_d=refresh_flag_q;
 		refresh_ctr_d=refresh_ctr_q+1'b1;
 		if(refresh_ctr_q==1070) begin //7.7 us
 			refresh_ctr_d=0;
 			refresh_flag_d=1;
 		end
 		
 		
 		
 		case(state_q)
 					////////////////BEGIN:INITIALIZE////////////////
 			delay: begin //wait here for a delay specified by delay_ctr_q(parameter in time specs)
 						delay_ctr_d=delay_ctr_q-1'b1;
 						if(delay_ctr_d==0) state_d=nxt_q;	
 						if(nxt_q==write) tri_d=1;
 					 end
 			start: begin //initiliaze after power-up
 						state_d=delay;
 						nxt_d=precharge_init;
 						delay_ctr_d=16'd30_000; //wait for 200us
 						s_addr_d=0;
 						s_ba_d=0;
 					 end
 precharge_init: begin //precharge ALL banks (A10 must be high)
 						state_d=delay;
 						nxt_d=refresh_1;
 						delay_ctr_d=t_RP-1;
 						cmd_d=cmd_precharge;
 						s_addr_d[10]=1'b1;
 					 end
 		refresh_1: begin
 						state_d=delay;
 						nxt_d=refresh_2;
 						delay_ctr_d=t_RC-1;
 						cmd_d=cmd_refresh;
 					  end
 		refresh_2: begin
 						state_d=delay;
 						nxt_d=load_mode_reg;
 						delay_ctr_d=t_RC-1;
 						cmd_d=cmd_refresh;
 					  end
   load_mode_reg: begin
 						state_d=delay;
 						nxt_d=idle;
 						delay_ctr_d=t_MRD-1;
 						cmd_d=cmd_setmode;
 						s_addr_d=13'b 000_0_00_011_0_111; //{reserved,writemode,reserved,CL,AddressingMode,BurstLength}
 						s_ba_d=2'b00; //reserved
 					  end
 					 ////////////////END:INITIALIZE////////////////
 					
 					////////////////BEGIN:NORMAL OPERATION////////////////
 		     idle: begin 
 						ready=rw_en_q? 0:1;
 						if(rw_en_q) begin //permission granted for r/w operation 
 								state_d=delay;
 								cmd_d=cmd_activate;
 								delay_ctr_d=t_RCD-1;
 								nxt_d=rw_q?read:write;
 								burst_index_d=0;
 								rw_en_d=1'b0;
 								{s_addr_d,s_ba_d}=f_addr_q;//row + bank addr
 						end
 						else if(refresh_flag_q || rw_en) begin  //refresh every 7.7us and BEFORE start of burst read/write operations
 							state_d=delay;
 							nxt_d=refresh;
 							delay_ctr_d=t_RP-1;
 							cmd_d=cmd_precharge; //precharge all banks first before auto-refresh
 							s_addr_d[10]=1'b1;
 							refresh_flag_d=0;
 							if(rw_en) begin 
 								rw_en_d=rw_en;
 								f_addr_d=f_addr; 
 								rw_d=rw;
 							end
 						end
 						
 					  end 
 	     refresh:	begin
 						 state_d=delay;
 						 nxt_d=idle;
 						 delay_ctr_d=t_RC-1;
 						 cmd_d=cmd_refresh;
 						end					 
 			read: begin 
 						state_d=delay;
 						delay_ctr_d=t_CL; //(WHYYY???)not subtracted by one since the sdram is "late" by half a cycle so register is one clk after the expected clock latency delay
 						cmd_d=cmd_read;
 						s_addr_d=0;//what column to activate(in full page mode, column starts at LEFTMOST which is zero)
 						s_ba_d=f_addr_q[1:0]; //what bank to activate
 						s_addr_d[10]=1'b0; //no auto-precharge for full page burst
 						nxt_d=read_data;
 					end
 	 read_data: begin //read data after CAS latency of 3 clk
 						s2f_data_d=s_dq_in;
 						s2f_data_valid_d=1'b1;
 						burst_index_d=burst_index_q+1;
 						if(burst_index_q==512) begin //if all 512 burst data is already finished, precharge then go back to idle
 							s2f_data_valid_d=1'b0;
 							state_d=delay;
 							nxt_d=idle;
 							delay_ctr_d=t_RP-1;
 							cmd_d=cmd_precharge;
 						end
 					end		
 		 write: begin  
 						f2s_data_d=f2s_data; //write data
 						f2s_data_valid=1'b1;
 						s_addr_d=0; //what column to activate(in full page mode, column starts at LEFTMOST which is zero)
 						s_ba_d=f_addr_q[1:0];
 						s_addr_d[10]=1'b0; //no auto-precharge for full page burst
 						tri_d=1'b1; //tristate buffer on since we output/write signals
 						cmd_d=cmd_write;
 						state_d=write_burst;
 						burst_index_d=burst_index_q+1;
 				   end
   write_burst: begin    //write data burst will start at assertion of f2s_data_valid
 						f2s_data_d=f2s_data; //write data
 						f2s_data_valid=1'b1; 
 						tri_d=1'b1; //tristate buffer on since we output/write signals
 						burst_index_d=burst_index_q+1;
 						
 						if(burst_index_q==512) begin //if all 512 burst data is already finished, precharge then go back to idle
 							tri_d=0;
 							state_d=delay;
 							f2s_data_valid=1'b0;
 							nxt_d=idle;
 							delay_ctr_d=t_RP+t_WR-1;
 							cmd_d=cmd_precharge;
 						end
 					end
 				  ////////////////END:NORMAL OPERATION////////////////
 				  
 		default: state_d=start;
 		endcase
 		
 		
 			
 	
 	end
 	
 	//assign the outputs to corresponding buffers
 	assign s_cs_n=cmd_q[3],
 			 s_ras_n=cmd_q[2],
 			 s_cas_n=cmd_q[1],
 			 s_we_n=cmd_q[0];
 	assign s_cke=1'b1; 
 	assign LDQM=1'b0, 
 			 HDQM=1'b0;
 	assign s_addr=s_addr_q;
 	assign s_ba=s_ba_q;
     //assign s_dq=tri_q? f2s_data_q:16'hzzzz; //tri-state output,tri=1 for write , tri=0 for read(hi-Z)
     //assign s_dq_in=s_dq;
 	assign s2f_data=s2f_data_q;
 	assign s2f_data_valid=s2f_data_valid_q;
 	assign s_dqm={HDQM,LDQM};
 	
 	
 
 	genvar i;
 	generate
 		for(i=0;i<16;i=i+1) begin
 			TRELLIS_IO #(.DIR("BIDIR")) u0
 			 (
 			  .B(s_dq[i]),
 			  .I(f2s_data_q[i]),
 			  .T({!tri_q}),
 			  .O(s_dq_in[i])
 			 );
 		end
 	endgenerate
 
endmodule
//---- Top entity
module vacc707 (
 input v06babe,
 input vb72568,
 input vc12365,
 input [7:0] v974bf7,
 input v62a627,
 input [15:0] v43e567,
 output v9cfd06,
 output vce526d,
 output [3:0] v3dc608
);
 wire [0:7] w0;
 wire [0:7] w1;
 wire [0:7] w2;
 wire [0:1] w3;
 wire [0:1] w4;
 wire [0:1] w5;
 wire [0:1] w6;
 wire [0:10] w7;
 wire [0:10] w8;
 wire w9;
 wire w10;
 wire [0:15] w11;
 wire w12;
 wire [0:3] w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire w21;
 wire [0:7] w22;
 assign w9 = vb72568;
 assign w10 = v62a627;
 assign w11 = v43e567;
 assign vce526d = w12;
 assign v3dc608 = w13;
 assign w14 = v06babe;
 assign v9cfd06 = w19;
 assign w21 = vc12365;
 assign w22 = v974bf7;
 assign w17 = w16;
 assign w18 = w15;
 assign w19 = w16;
 assign w19 = w17;
 v62743d vfdf156 (
  .v7d92a9(w14),
  .v59e075(w15),
  .vf8ffa2(w16)
 );
 v45dab8 v6eb500 (
  .v537e7f(w0),
  .v107509(w1),
  .v6025d7(w2),
  .v10aa67(w3),
  .vb39924(w4),
  .v1ace6d(w5),
  .v30f9a1(w6),
  .veb1d23(w7),
  .va0ee93(w8),
  .vd4b130(w17),
  .vef38fc(w18),
  .v7f6c3e(w20)
 );
 vacc707_ve858d4 ve858d4 (
  .red(w0),
  .green(w1),
  .blue(w2),
  .tmds_red(w3),
  .tmds_green(w4),
  .tmds_blue(w5),
  .tmds_clk(w6),
  .pixel_x(w7),
  .pixel_y(w8),
  .rst_n(w9),
  .empty_fifo(w10),
  .din(w11),
  .rd_en(w12),
  .gpdi_dp(w13),
  .clk_5x(w15),
  .clk_vga(w16),
  .blank(w20),
  .sobel(w21),
  .threshold(w22)
 );
endmodule

//---------------------------------------------------
//-- hdmi_interface
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Receives pixel data from SDRAM to be displayed on monitor
//---------------------------------------------------

module vacc707_ve858d4 (
 input clk_5x,
 input clk_vga,
 input rst_n,
 input sobel,
 input [7:0] threshold,
 input empty_fifo,
 input [15:0] din,
 input blank,
 input [1:0] tmds_red,
 input [1:0] tmds_green,
 input [1:0] tmds_blue,
 input [1:0] tmds_clk,
 input [10:0] pixel_x,
 input [10:0] pixel_y,
 output rd_en,
 output [3:0] gpdi_dp,
 output [7:0] red,
 output [7:0] green,
 output [7:0] blue
);
 	 reg rd_en;
 	 //FSM state declarations
 	 //FSM state declarations
 	 localparam delay=0,
 					idle=1,
 					display=2,
 					align_frame=1,
 					align_idle=0;
 					
 	 reg[1:0] state_q,state_d;
 	 reg[7:0] red,green,blue;
 	 wire[1:0] tmds_red,tmds_green,tmds_blue,tmds_clk;
 	 wire clk_5x;
 	 reg sobel_prev,state_align_q,state_align_d;
 	 reg[4:0] align_count_q,align_count_d;
 	 
 	 //register operations
 	 always @(posedge clk_vga,negedge rst_n) begin
 		if(!rst_n) begin
 			state_q<=delay;
 			state_align_q<=align_idle;
 			align_count_q<=0;
 		end
 		else begin
 			state_q<=state_d;
 			sobel_prev<=sobel;
 			state_align_q<=state_align_d;
 			align_count_q<=align_count_d;
 		end
 	 end
 	 
 	 //FSM next-state logic
 	 always @* begin
 	 state_d=state_q;
 	 state_align_d=state_align_q;
 	 align_count_d=align_count_q;
 	 rd_en=0;
 	 red=0;
 	 green=0;
 	 blue=0;
 			
 		case(state_q)
 		 delay: if(blank) begin
 					state_d=idle;
 					state_align_d=align_frame;
 				 end
 			idle:  if(pixel_x==0 && pixel_y==0 && !empty_fifo) begin //wait for pixel-data coming from asyn_fifo 	
 							if(sobel) begin
 								red=(din>threshold)? 8'hff:0;
     							green=(din>threshold)? 8'hff:0;
     							blue=(din>threshold)? 8'hff:0;
 								/*red=din[7:0]; //grayscale
 								green=din[7:0];
 								blue=din[7:0];*/
 							end
 							else begin
 								red=din[15:11]<<3;
 								green=din[10:5]<<2;
 								blue=din[4:0]<<3;
 							end
 							rd_en=1;	
 							state_d=display;
 					end
 		display: if(!blank) begin //we will continue to read the asyn_fifo as long as current pixel coordinate is inside the visible screen(640x480) 
 							if(sobel) begin
 								red=(din>threshold)? 8'hff:0;
 								green=(din>threshold)? 8'hff:0;
 								blue=(din>threshold)? 8'hff:0;
 							end
 							else begin
 								red=din[15:11]<<3;
 								green=din[10:5]<<2;
 								blue=din[4:0]<<3;
 							end
 							rd_en=1;	
 					end
 		default: state_d=delay;
 		endcase
 		
 		
 		//automatically aligns frame when display changes (sobel-> rgb or rgb->sobel)
 		case(state_align_q)
 			 align_idle: if(sobel_prev != sobel) begin 
 								state_align_d=align_frame;
 								align_count_d=0;
 						 end
 			align_frame:  begin
 							if(sobel && din[8] && din[15:9]==0 && rd_en) begin //align sobel frame 
 								if(pixel_x==0 && pixel_y==0) begin 
 									rd_en=1;
 									align_count_d=align_count_q+1'b1;
 									if(align_count_q==5) state_align_d=align_idle; //align for 5 frames
 								end
 								else rd_en=0;
 							end
 							else if(!sobel && din==16'b00000_000000_11111 && rd_en) begin //align rgb fram
 								if(pixel_x==0 && pixel_y==0) begin 
 									rd_en=1;
 									align_count_d=align_count_q+1'b1;
 									if(align_count_q==5) state_align_d=align_idle; //align for 5 frames
 								end
 								else rd_en=0;
 							end
 						  end
 				default: state_align_d=align_idle;
 		endcase
 	 end
  
 	
 	//ODDR instantiatons for Double-Data Rate operation
 		ODDRX1F ddr0_clock (.D0(tmds_clk   [0] ), .D1(tmds_clk   [1] ), .Q(gpdi_dp[3]), .SCLK(clk_5x), .RST(0));
         ODDRX1F ddr0_red   (.D0(tmds_red   [0] ), .D1(tmds_red   [1] ), .Q(gpdi_dp[2]), .SCLK(clk_5x), .RST(0));
         ODDRX1F ddr0_green (.D0(tmds_green [0] ), .D1(tmds_green [1] ), .Q(gpdi_dp[1]), .SCLK(clk_5x), .RST(0));
         ODDRX1F ddr0_blue  (.D0(tmds_blue  [0] ), .D1(tmds_blue  [1] ), .Q(gpdi_dp[0]), .SCLK(clk_5x), .RST(0));
 		
 		
endmodule
//---- Top entity
module v62743d (
 input v7d92a9,
 output v59e075,
 output vf8ffa2
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v7d92a9;
 assign vf8ffa2 = w1;
 assign v59e075 = w2;
 v62743d_v829c03 v829c03 (
  .clkin(w0),
  .clkout1(w1),
  .clkout0(w2)
 );
endmodule

//---------------------------------------------------
//-- pll_HDMI
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Converts 25MHz clk to 25MHz(VGA) and 125MHz(HDMI)
//---------------------------------------------------

module v62743d_v829c03 (
 input clkin,
 output clkout0,
 output clkout1
);
 wire locked;
 
 (* FREQUENCY_PIN_CLKI="25" *)
 (* FREQUENCY_PIN_CLKOP="125" *)
 (* FREQUENCY_PIN_CLKOS="25" *)
 (* ICP_CURRENT="12" *) (* LPF_RESISTOR="8" *) (* MFG_ENABLE_FILTEROPAMP="1" *) (* MFG_GMCREF_SEL="2" *)
 EHXPLLL #(
         .PLLRST_ENA("DISABLED"),
         .INTFB_WAKE("DISABLED"),
         .STDBY_ENABLE("DISABLED"),
         .DPHASE_SOURCE("DISABLED"),
         .OUTDIVIDER_MUXA("DIVA"),
         .OUTDIVIDER_MUXB("DIVB"),
         .OUTDIVIDER_MUXC("DIVC"),
         .OUTDIVIDER_MUXD("DIVD"),
         .CLKI_DIV(1),
         .CLKOP_ENABLE("ENABLED"),
         .CLKOP_DIV(5),
         .CLKOP_CPHASE(2),
         .CLKOP_FPHASE(0),
         .CLKOS_ENABLE("ENABLED"),
         .CLKOS_DIV(25),
         .CLKOS_CPHASE(2),
         .CLKOS_FPHASE(0),
         .FEEDBK_PATH("CLKOP"),
         .CLKFB_DIV(5)
     ) pll_i (
         .RST(1'b0),
         .STDBY(1'b0),
         .CLKI(clkin),
         .CLKOP(clkout0),
         .CLKOS(clkout1),
         .CLKFB(clkout0),
         .CLKINTFB(),
         .PHASESEL0(1'b0),
         .PHASESEL1(1'b0),
         .PHASEDIR(1'b1),
         .PHASESTEP(1'b1),
         .PHASELOADREG(1'b1),
         .PLLWAKESYNC(1'b0),
         .ENCLKOP(1'b0),
         .LOCK(locked)
 	);
endmodule
//---- Top entity
module v45dab8 (
 input vd4b130,
 input vef38fc,
 input [7:0] v537e7f,
 input [7:0] v107509,
 input [7:0] v6025d7,
 output v7f6c3e,
 output [10:0] veb1d23,
 output [10:0] va0ee93,
 output [1:0] v10aa67,
 output [1:0] vb39924,
 output [1:0] v1ace6d,
 output [1:0] v30f9a1
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire [0:7] w9;
 wire [0:7] w10;
 wire [0:7] w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire [0:9] w18;
 wire w19;
 wire [0:1] w20;
 wire [0:1] w21;
 wire [0:1] w22;
 wire [0:1] w23;
 wire [0:9] w24;
 wire [0:9] w25;
 wire [0:10] w26;
 wire [0:10] w27;
 wire w28;
 assign w0 = vd4b130;
 assign w2 = vd4b130;
 assign w3 = vd4b130;
 assign w4 = vd4b130;
 assign w9 = v537e7f;
 assign w10 = v107509;
 assign w11 = v6025d7;
 assign w19 = vef38fc;
 assign v10aa67 = w20;
 assign vb39924 = w21;
 assign v1ace6d = w22;
 assign v30f9a1 = w23;
 assign veb1d23 = w26;
 assign va0ee93 = w27;
 assign v7f6c3e = w28;
 assign w2 = w0;
 assign w3 = w0;
 assign w3 = w2;
 assign w4 = w0;
 assign w4 = w2;
 assign w4 = w3;
 assign w7 = w6;
 assign w8 = w6;
 assign w8 = w7;
 assign w13 = w12;
 assign w15 = w14;
 assign w28 = w5;
 v45dab8_v18a10e v18a10e (
  .pclk(w0),
  .reset_n(w1),
  .out_blank(w5),
  .out_vsync(w16),
  .out_hsync(w17),
  .out_hcnt(w26),
  .out_vcnt(w27)
 );
 vc83dcd v25cda8 (
  .v608bd9(w1)
 );
 v96f098 v333637 (
  .v0e28cb(w5),
  .vcbab45(w6)
 );
 vc4dd08 vfb69db (
  .v608bd9(w12)
 );
 vc4dd08 v15a0b4 (
  .v608bd9(w14)
 );
 v45dab8_v126bbf v126bbf (
  .tmds_blue(w18),
  .tmds_clk(w19),
  .out_tmds_red(w20),
  .out_tmds_green(w21),
  .out_tmds_blue(w22),
  .out_tmds_clk(w23),
  .tmds_red(w24),
  .tmds_green(w25)
 );
 vcb4e6d vc4fba0 (
  .vdd711c(w2),
  .v3653dc(w6),
  .v11f67f(w9),
  .v015605(w12),
  .vbca4a6(w13),
  .v90c336(w24)
 );
 vcb4e6d ve76285 (
  .vdd711c(w3),
  .v3653dc(w7),
  .v11f67f(w10),
  .v015605(w14),
  .vbca4a6(w15),
  .v90c336(w25)
 );
 vcb4e6d v2f7048 (
  .vdd711c(w4),
  .v3653dc(w8),
  .v11f67f(w11),
  .v015605(w16),
  .vbca4a6(w17),
  .v90c336(w18)
 );
endmodule

//---------------------------------------------------
//-- HDMI_controller
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- HDMI controller with DDR enabled
//---------------------------------------------------

module v45dab8_v18a10e (
 input pclk,
 input reset_n,
 output out_hsync,
 output out_vsync,
 output out_blank,
 output [10:0] out_hcnt,
 output [10:0] out_vcnt
);
 //Copyright (C) 2021 Hirosh Dabui hirosh@dabui.de
 
 localparam
 	/* VGA_1280x720@60Hz */          
 		 VPOL            = 1,	      
 		 HPOL            = 0,	      
 		 FRAME_RATE      = 30,	    
 	/* vertical timing frame */     
 		 VBP             = 33,      
 		 VFP             = 10,      
 		 VSLEN           = 2,	      
 		 VACTIVE         = 480,	    
 	/* horizontal timing frame */   
 		 HBP             = 48,	    
 		 HFP             = 16,	    
 		 HSLEN           = 96,	    
 		 HACTIVE         = 640;
 //////////////////////////////////////
 
 localparam VTOTAL            = VACTIVE + VFP + VSLEN + VBP;	
 localparam HTOTAL            = HACTIVE + HFP + HSLEN + HBP;	
 localparam PIXEL_CLK         = (VTOTAL * HTOTAL) * FRAME_RATE;
 
 reg[10:0] out_hcnt,out_vcnt;
 	//Display Final Values 
 	initial begin 
 	  $display("VACTIVE:%d", VACTIVE); 
 	  $display("HACTIVE:%d", HACTIVE); 
 	  $display("VBP:%d", VBP);
 	  $display("VFP:%d", VFP); 
 	  $display("HBP:%d", HBP); 
 	  $display("HFP:%d", HFP); 
 	  $display("VSLEN:%d", VSLEN); 
 	  $display("HSLEN:%d", HSLEN); 
 	  $display("VTOTAL:%d", VTOTAL); 
 	  $display("HTOTAL:%d", HTOTAL); 
 	  $display("Framerate:%d", FRAME_RATE); 
 	  $display("PIXEL Frequency:%d", PIXEL_CLK); 
 	end 
 	
     /*
      *
      *         +
      *         |
      *         | VACTIVE
      *         |
      *         |       HACTIVE            HFP    HSLEN    HBP
      *         ------------------------++-----++-------+------+
      *         |
      *         |
      *         |
      *         |
      *         |
      *         +
      *         | VFP
      *         +
      *         +
      *         |
      *         | VSLEN
      *         |
      *         +
      *         +
      *         |
      *         | HBP
      *         |
      *         +
      *
      */
 
 
 
 assign out_vsync = ((out_vcnt >= (VACTIVE + VFP -1)) && (out_vcnt < (VACTIVE + VFP + VSLEN))) ^ ~VPOL;
 assign out_hsync = ((out_hcnt >= (HACTIVE + HFP -1)) && (out_hcnt < (HACTIVE + HFP + HSLEN))) ^ ~HPOL;
 assign out_blank = (out_hcnt >= HACTIVE) || (out_vcnt >= VACTIVE);
 
 wire hcycle = out_hcnt == (HTOTAL -1) || ~reset_n;
 wire vcycle = out_vcnt == (VTOTAL -1) || ~reset_n;
 
 always @(posedge pclk) out_hcnt <= hcycle ? 0 : out_hcnt + 1;
 
 always @(posedge pclk) begin
     if (hcycle) out_vcnt <= vcycle ? 0 : out_vcnt + 1;
 end
 
endmodule

module v45dab8_v126bbf (
 input tmds_clk,
 input [9:0] tmds_red,
 input [9:0] tmds_green,
 input [9:0] tmds_blue,
 output [1:0] out_tmds_red,
 output [1:0] out_tmds_green,
 output [1:0] out_tmds_blue,
 output [1:0] out_tmds_clk
);
 //Copyright (C) 2021 Hirosh Dabui hirosh@dabui.de
 
 localparam DDR_ENABLED=1,
             OUT_TMDS_MSB = DDR_ENABLED ? 1 : 0;
 
 
 /**/
 reg       tmds_shift_load   = 0;
 reg [3:0] tmds_modulo       = 0;
 reg [9:0] tmds_shift_red    = 0;
 reg [9:0] tmds_shift_green  = 0;
 reg [9:0] tmds_shift_blue   = 0;
 reg [9:0] tmds_shift_clk    = 0;
 
 wire [9:0] tmds_pixel_clk = 10'b00000_11111;
 
 
 wire max_shifts_reached = tmds_modulo == (DDR_ENABLED ? 4 : 9);
 always @(posedge tmds_clk) tmds_modulo      <= max_shifts_reached ? 0 : tmds_modulo + 1;
 always @(posedge tmds_clk) tmds_shift_load  <= max_shifts_reached;
 
 always @(posedge tmds_clk) begin //shifts 2-bits at a time if DDR is enabled, else shift 1-bit at a time
     tmds_shift_red    <= tmds_shift_load ? tmds_red       : {DDR_ENABLED ? 2'b00 : 1'b0, tmds_shift_red   [9: DDR_ENABLED ? 2 : 1]};
     tmds_shift_green  <= tmds_shift_load ? tmds_green     : {DDR_ENABLED ? 2'b00 : 1'b0, tmds_shift_green [9: DDR_ENABLED ? 2 : 1]};
     tmds_shift_blue   <= tmds_shift_load ? tmds_blue      : {DDR_ENABLED ? 2'b00 : 1'b0, tmds_shift_blue  [9: DDR_ENABLED ? 2 : 1]};
     tmds_shift_clk    <= tmds_shift_load ? tmds_pixel_clk : {DDR_ENABLED ? 2'b00 : 1'b0, tmds_shift_clk   [9: DDR_ENABLED ? 2 : 1]};
 end
 
 assign out_tmds_clk   = tmds_shift_clk    [ OUT_TMDS_MSB : 0 ];
 assign out_tmds_red   = tmds_shift_red    [ OUT_TMDS_MSB : 0 ];
 assign out_tmds_green = tmds_shift_green  [ OUT_TMDS_MSB : 0 ];
 assign out_tmds_blue  = tmds_shift_blue   [ OUT_TMDS_MSB : 0 ];
endmodule
//---- Top entity
module vc83dcd (
 output v608bd9
);
 wire w0;
 assign v608bd9 = w0;
 vc83dcd_v68c173 v68c173 (
  .v(w0)
 );
endmodule

//---------------------------------------------------
//-- Bit 1
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Assign 1 to the output wire
//---------------------------------------------------

module vc83dcd_v68c173 (
 output v
);
 // Bit 1
 
 assign v = 1'b1;
endmodule
//---- Top entity
module v96f098 (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v96f098_vd54ca1 vd54ca1 (
  .a(w0),
  .c(w1)
 );
endmodule

//---------------------------------------------------
//-- NOT
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- NOT logic gate
//---------------------------------------------------

module v96f098_vd54ca1 (
 input a,
 output c
);
 // NOT logic gate
 
 assign c = ~ a;
endmodule
//---- Top entity
module vc4dd08 (
 output v608bd9
);
 wire w0;
 assign v608bd9 = w0;
 vc4dd08_v68c173 v68c173 (
  .v(w0)
 );
endmodule

//---------------------------------------------------
//-- Bit 0
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- Assign 0 to the output wire
//---------------------------------------------------

module vc4dd08_v68c173 (
 output v
);
 // Bit 0
 
 assign v = 1'b0;
endmodule
//---- Top entity
module vcb4e6d (
 input vdd711c,
 input v3653dc,
 input [7:0] v11f67f,
 input v015605,
 input vbca4a6,
 output [9:0] v90c336
);
 wire [0:9] w0;
 wire w1;
 wire w2;
 wire [0:7] w3;
 wire w4;
 wire w5;
 assign v90c336 = w0;
 assign w1 = vdd711c;
 assign w2 = v3653dc;
 assign w3 = v11f67f;
 assign w4 = v015605;
 assign w5 = vbca4a6;
 vcb4e6d_v07d31b v07d31b (
  .q_out(w0),
  .clk(w1),
  .DE(w2),
  .D(w3),
  .C1(w4),
  .C0(w5)
 );
endmodule

//---------------------------------------------------
//-- tmds_encoder
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- 
//---------------------------------------------------

module vcb4e6d_v07d31b (
 input clk,
 input DE,
 input [7:0] D,
 input C1,
 input C0,
 output [9:0] q_out
);
 //Copyright (C) 2021 Hirosh Dabui hirosh@dabui.de
 
 parameter LEGACY_DVI_CONTROL_LUT = 0;
 reg[9:0] q_out;
 function [3:0] N0;
     input [7:0] d;
     integer i;
     begin
         N0 = 0;
         for (i = 0; i < 8; i=i+1)
             N0 = N0 + !d[i];
     end
 endfunction
 
 function [3:0] N1;
     input [7:0] d;
     integer i;
     begin
         N1 = 0;
         for (i = 0; i < 8; i=i+1)
             N1 = N1 + d[i];
     end
 endfunction
 
 reg signed [7:0] cnt_prev = 0;
 reg signed [7:0] cnt = 0;
 
 reg [8:0] q_m;
 
 always @(*) begin
 
     if ( (N1(D) > 4) | (N1(D) == 4) & (D[0] == 0) ) begin
 
         q_m[0] =           D[0];
         q_m[1] = q_m[0] ~^ D[1];
         q_m[2] = q_m[1] ~^ D[2];
         q_m[3] = q_m[2] ~^ D[3];
         q_m[4] = q_m[3] ~^ D[4];
         q_m[5] = q_m[4] ~^ D[5];
         q_m[6] = q_m[5] ~^ D[6];
         q_m[7] = q_m[6] ~^ D[7];
         q_m[8] = 1'b0;
 
     end else begin
 
         q_m[0] =          D[0];
         q_m[1] = q_m[0] ^ D[1];
         q_m[2] = q_m[1] ^ D[2];
         q_m[3] = q_m[2] ^ D[3];
         q_m[4] = q_m[3] ^ D[4];
         q_m[5] = q_m[4] ^ D[5];
         q_m[6] = q_m[5] ^ D[6];
         q_m[7] = q_m[6] ^ D[7];
         q_m[8] = 1'b1;
 
     end /* (N1(D) > 4) | (N1(D) == 4) & (D[0] == 0) */
 
 end
 
 always @(posedge clk) begin
 
     if (DE) begin
 
         if ((cnt_prev == 0) | (N1(q_m[7:0]) == N0(q_m[7:0]))) begin
 
             q_out[9]   <= ~q_m[8];
             q_out[8]   <=  q_m[8];
             q_out[7:0] <= q_m[8] ? q_m[7:0] : ~q_m[7:0];
 
             if (q_m[8] == 0) begin
                 cnt = cnt_prev + (N0(q_m[7:0]) - N1(q_m[7:0]));
             end else begin
                 cnt = cnt_prev + (N1(q_m[7:0]) - N0(q_m[7:0]));
             end /*q_m[8] == 0*/
 
         end else begin
 
             if ( (cnt_prev > 0 & (N1(q_m[7:0]) > N0(q_m[7:0]))) |
                     (cnt_prev < 0 & (N0(q_m[7:0]) > N1(q_m[7:0]))) ) begin
                 q_out[9] <= 1;
                 q_out[8] <= q_m[8];
                 q_out[7:0] <= ~q_m[7:0];
                 cnt = cnt_prev + 2*q_m[8] + (N0(q_m[7:0]) - N1(q_m[7:0]));
             end else begin
                 q_out[9] <= 0;
                 q_out[8] <= q_m[8];
                 q_out[7:0] <= q_m[7:0];
                 cnt = cnt_prev + 2*(~q_m[8]) + (N1(q_m[7:0]) - N0(q_m[7:0]));
             end /*
                 (cnt_prev > 0 & N1(q_m[7:0]) > N0(q_m[7:0]))) |
                 (cnt_prev < 0 & N0(q_m[7:0]) > N1(q_m[7:0])))
               */
 
         end /* ((cnt_prev == 0) | (N1(q_m[7:0]) == N0(q_m[7:0]))) */
 
     end else begin
         /* !DE */
         cnt = 0;
         /* hsync -> c0 | vsync -> c1 */
         case ({C1, C0})
 `ifdef LEGACY_DVI_CONTROL_LUT
             /* dvi control data lut */
             2'b00: q_out <= 10'b00101_01011;
             2'b01: q_out <= 10'b11010_10100;
             2'b10: q_out <= 10'b00101_01010;
             2'b11: q_out <= 10'b11010_10101;
 `else
             /* hdmi control data period */
             2'b00: q_out <= 10'b1101010100;
             2'b01: q_out <= 10'b0010101011;
             2'b10: q_out <= 10'b0101010100;
             2'b11: q_out <= 10'b1010101011;
 `endif
         endcase
 
     end /* DE */
 
     cnt_prev <= cnt;
 
 end
 
endmodule
//---- Top entity
module v215c29 (
 input v1330f7,
 input vac6e8a,
 input [16:0] va6a902,
 input [10:0] v8418a8,
 input v4b9b10,
 input v6391f5,
 input v3f3eec,
 input vfdf113,
 input v2c85c6,
 output va47e6c,
 output v3024c9,
 output v2775c6,
 output [10:0] v312c43,
 output [8:0] vfe3990,
 output [7:0] v4c8564
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire [0:10] w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire w27;
 wire w28;
 wire w29;
 wire w30;
 wire w31;
 wire w32;
 wire [0:10] w33;
 wire w34;
 wire w35;
 wire w36;
 wire [0:7] w37;
 wire w38;
 wire w39;
 wire w40;
 wire w41;
 wire w42;
 wire [0:16] w43;
 wire [0:8] w44;
 wire [0:9] w45;
 wire [0:9] w46;
 wire [0:8] w47;
 wire [0:9] w48;
 wire [0:9] w49;
 wire [0:8] w50;
 wire [0:9] w51;
 wire [0:9] w52;
 wire [0:8] w53;
 wire [0:9] w54;
 wire [0:9] w55;
 wire [0:8] w56;
 wire [0:9] w57;
 wire [0:9] w58;
 wire [0:8] w59;
 wire [0:9] w60;
 wire [0:9] w61;
 wire [0:8] w62;
 wire [0:8] w63;
 wire [0:8] w64;
 wire [0:8] w65;
 wire [0:8] w66;
 wire [0:8] w67;
 wire [0:8] w68;
 wire [0:8] w69;
 assign w0 = vac6e8a;
 assign w1 = v1330f7;
 assign w2 = v1330f7;
 assign w3 = v1330f7;
 assign w4 = v1330f7;
 assign w5 = v1330f7;
 assign w6 = v1330f7;
 assign w7 = v1330f7;
 assign w8 = v1330f7;
 assign w9 = v1330f7;
 assign w10 = v1330f7;
 assign w11 = v1330f7;
 assign w12 = v1330f7;
 assign w18 = v1330f7;
 assign w20 = v3f3eec;
 assign v312c43 = w21;
 assign va47e6c = w22;
 assign w24 = vac6e8a;
 assign w25 = v1330f7;
 assign v3024c9 = w26;
 assign w27 = v4b9b10;
 assign w28 = v1330f7;
 assign w29 = v1330f7;
 assign w30 = v1330f7;
 assign w31 = v6391f5;
 assign w32 = vfdf113;
 assign w33 = v8418a8;
 assign v2775c6 = w36;
 assign v4c8564 = w37;
 assign w38 = v2c85c6;
 assign w40 = v1330f7;
 assign w41 = v1330f7;
 assign w42 = vac6e8a;
 assign w43 = va6a902;
 assign vfe3990 = w69;
 assign w2 = w1;
 assign w3 = w1;
 assign w3 = w2;
 assign w4 = w1;
 assign w4 = w2;
 assign w4 = w3;
 assign w5 = w1;
 assign w5 = w2;
 assign w5 = w3;
 assign w5 = w4;
 assign w6 = w1;
 assign w6 = w2;
 assign w6 = w3;
 assign w6 = w4;
 assign w6 = w5;
 assign w7 = w1;
 assign w7 = w2;
 assign w7 = w3;
 assign w7 = w4;
 assign w7 = w5;
 assign w7 = w6;
 assign w8 = w1;
 assign w8 = w2;
 assign w8 = w3;
 assign w8 = w4;
 assign w8 = w5;
 assign w8 = w6;
 assign w8 = w7;
 assign w9 = w1;
 assign w9 = w2;
 assign w9 = w3;
 assign w9 = w4;
 assign w9 = w5;
 assign w9 = w6;
 assign w9 = w7;
 assign w9 = w8;
 assign w10 = w1;
 assign w10 = w2;
 assign w10 = w3;
 assign w10 = w4;
 assign w10 = w5;
 assign w10 = w6;
 assign w10 = w7;
 assign w10 = w8;
 assign w10 = w9;
 assign w11 = w1;
 assign w11 = w2;
 assign w11 = w3;
 assign w11 = w4;
 assign w11 = w5;
 assign w11 = w6;
 assign w11 = w7;
 assign w11 = w8;
 assign w11 = w9;
 assign w11 = w10;
 assign w12 = w1;
 assign w12 = w2;
 assign w12 = w3;
 assign w12 = w4;
 assign w12 = w5;
 assign w12 = w6;
 assign w12 = w7;
 assign w12 = w8;
 assign w12 = w9;
 assign w12 = w10;
 assign w12 = w11;
 assign w18 = w1;
 assign w18 = w2;
 assign w18 = w3;
 assign w18 = w4;
 assign w18 = w5;
 assign w18 = w6;
 assign w18 = w7;
 assign w18 = w8;
 assign w18 = w9;
 assign w18 = w10;
 assign w18 = w11;
 assign w18 = w12;
 assign w24 = w0;
 assign w25 = w1;
 assign w25 = w2;
 assign w25 = w3;
 assign w25 = w4;
 assign w25 = w5;
 assign w25 = w6;
 assign w25 = w7;
 assign w25 = w8;
 assign w25 = w9;
 assign w25 = w10;
 assign w25 = w11;
 assign w25 = w12;
 assign w25 = w18;
 assign w28 = w1;
 assign w28 = w2;
 assign w28 = w3;
 assign w28 = w4;
 assign w28 = w5;
 assign w28 = w6;
 assign w28 = w7;
 assign w28 = w8;
 assign w28 = w9;
 assign w28 = w10;
 assign w28 = w11;
 assign w28 = w12;
 assign w28 = w18;
 assign w28 = w25;
 assign w29 = w1;
 assign w29 = w2;
 assign w29 = w3;
 assign w29 = w4;
 assign w29 = w5;
 assign w29 = w6;
 assign w29 = w7;
 assign w29 = w8;
 assign w29 = w9;
 assign w29 = w10;
 assign w29 = w11;
 assign w29 = w12;
 assign w29 = w18;
 assign w29 = w25;
 assign w29 = w28;
 assign w30 = w1;
 assign w30 = w2;
 assign w30 = w3;
 assign w30 = w4;
 assign w30 = w5;
 assign w30 = w6;
 assign w30 = w7;
 assign w30 = w8;
 assign w30 = w9;
 assign w30 = w10;
 assign w30 = w11;
 assign w30 = w12;
 assign w30 = w18;
 assign w30 = w25;
 assign w30 = w28;
 assign w30 = w29;
 assign w40 = w1;
 assign w40 = w2;
 assign w40 = w3;
 assign w40 = w4;
 assign w40 = w5;
 assign w40 = w6;
 assign w40 = w7;
 assign w40 = w8;
 assign w40 = w9;
 assign w40 = w10;
 assign w40 = w11;
 assign w40 = w12;
 assign w40 = w18;
 assign w40 = w25;
 assign w40 = w28;
 assign w40 = w29;
 assign w40 = w30;
 assign w41 = w1;
 assign w41 = w2;
 assign w41 = w3;
 assign w41 = w4;
 assign w41 = w5;
 assign w41 = w6;
 assign w41 = w7;
 assign w41 = w8;
 assign w41 = w9;
 assign w41 = w10;
 assign w41 = w11;
 assign w41 = w12;
 assign w41 = w18;
 assign w41 = w25;
 assign w41 = w28;
 assign w41 = w29;
 assign w41 = w30;
 assign w41 = w40;
 assign w42 = w0;
 assign w42 = w24;
 assign w47 = w44;
 assign w48 = w46;
 assign w49 = w45;
 assign w50 = w44;
 assign w50 = w47;
 assign w51 = w46;
 assign w51 = w48;
 assign w52 = w45;
 assign w52 = w49;
 assign w55 = w45;
 assign w55 = w49;
 assign w55 = w52;
 assign w56 = w53;
 assign w57 = w54;
 assign w58 = w45;
 assign w58 = w49;
 assign w58 = w52;
 assign w58 = w55;
 assign w59 = w53;
 assign w59 = w56;
 assign w60 = w54;
 assign w60 = w57;
 assign w61 = w45;
 assign w61 = w49;
 assign w61 = w52;
 assign w61 = w55;
 assign w61 = w58;
 vcfd9ba v61e668 (
  .v444878(w28),
  .v6a82dd(w31),
  .vd4e5d7(w34)
 );
 vcfd9ba vc0e8db (
  .v444878(w29),
  .v6a82dd(w32),
  .vd4e5d7(w35)
 );
 v215c29_v2d8c02 v2d8c02 (
  .key1(w34),
  .key2(w35),
  .sobel(w36),
  .threshold(w37),
  .key3(w39),
  .clk(w41),
  .rst_n(w42)
 );
 vcfd9ba v5bfbe7 (
  .v6a82dd(w38),
  .vd4e5d7(w39),
  .v444878(w40)
 );
 v215c29_v285763 v285763 (
  .rst_n(w0),
  .we_2(w13),
  .we_3(w14),
  .we_4(w15),
  .we_5(w16),
  .we_6(w17),
  .write(w19),
  .rd_en(w22),
  .we_1(w23),
  .clk_w(w25),
  .rd_fifo_cam(w26),
  .data_count_r_sobel(w33),
  .din(w43),
  .din_ram_y(w44),
  .addr_b_d(w45),
  .addr_a_y(w46),
  .din_ram_x(w53),
  .addr_a_x(w54),
  .dout_1(w62),
  .dout_2(w63),
  .dout_3(w64),
  .dout_4(w65),
  .dout_5(w66),
  .dout_6(w67),
  .data_write(w68)
 );
 v71739f v4903d1 (
  .vf6ac69(w11),
  .ve163d2(w12),
  .va43ab9(w23),
  .vfe854d(w44),
  .v7583c7(w45),
  .vf3d037(w46),
  .vb08192(w62)
 );
 v71739f v7e62b7 (
  .vf6ac69(w1),
  .ve163d2(w2),
  .va43ab9(w13),
  .vfe854d(w47),
  .vf3d037(w48),
  .v7583c7(w49),
  .vb08192(w63)
 );
 v71739f v50535c (
  .vf6ac69(w3),
  .ve163d2(w4),
  .va43ab9(w14),
  .vfe854d(w50),
  .vf3d037(w51),
  .v7583c7(w52),
  .vb08192(w64)
 );
 v71739f v10bcc8 (
  .vf6ac69(w5),
  .ve163d2(w6),
  .va43ab9(w15),
  .vfe854d(w53),
  .vf3d037(w54),
  .v7583c7(w55),
  .vb08192(w65)
 );
 v71739f vfa02b8 (
  .vf6ac69(w7),
  .ve163d2(w8),
  .va43ab9(w16),
  .vfe854d(w56),
  .vf3d037(w57),
  .v7583c7(w58),
  .vb08192(w66)
 );
 v71739f v22f959 (
  .vf6ac69(w9),
  .ve163d2(w10),
  .va43ab9(w17),
  .vfe854d(w59),
  .vf3d037(w60),
  .v7583c7(w61),
  .vb08192(w67)
 );
 v1932d4 veb1519 (
  .vc312eb(w18),
  .vbecff9(w19),
  .v88873d(w20),
  .vffb9ca(w21),
  .v154578(w24),
  .v14fb5c(w27),
  .v2720e8(w68),
  .vfba775(w69)
 );
endmodule

//---------------------------------------------------
//-- sobel_convolution
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- pipelined sobel convolution logic
//---------------------------------------------------

module v215c29_v2d8c02 (
 input clk,
 input rst_n,
 input key1,
 input key2,
 input key3,
 output sobel,
 output [7:0] threshold
);
 	 reg[7:0] threshold=0;
 	 reg sobel=0;
 	 reg key1_prev,key2_prev,key3_prev;
 	 reg key1_tick,key2_tick,key3_tick;
 
 	always @(posedge clk) begin
 		if(!rst_n) begin
 			threshold=0;
 			sobel<=0;
 		end
     	else begin
             key1_prev<=key1;
     	    key2_prev<=key2;
     	    key3_prev<=key3;
     	    
     	    key1_tick=!key1_prev && key1;
     	    key2_tick=!key2_prev && key2;
     	    key3_tick=!key3_prev && key3;
     	    
 			threshold=key1_tick? threshold+1:threshold;  //decrease sensitivity of sobel edge detection
 			threshold=key2_tick? threshold-1:threshold;	//increase sensitivity of sobel edge detection
 			sobel<=key3_tick? !sobel:sobel; //choose whether to display the raw videoe or the edge detected video
 		end
 	end
endmodule

module v215c29_v285763 (
 input clk_w,
 input clk_r,
 input rst_n,
 input [16:0] din,
 input [10:0] data_count_r_sobel,
 input [8:0] dout_1,
 input [8:0] dout_2,
 input [8:0] dout_3,
 input [8:0] dout_4,
 input [8:0] dout_5,
 input [8:0] dout_6,
 output rd_en,
 output rd_fifo_cam,
 output we_1,
 output we_2,
 output we_3,
 output we_4,
 output we_5,
 output we_6,
 output [8:0] din_ram_y,
 output [8:0] din_ram_x,
 output [9:0] addr_a_y,
 output [9:0] addr_a_x,
 output [9:0] addr_b_d,
 output write,
 output [8:0] data_write
);
 	 //FSM for combining the kernels which will then be stored in asyn_fifo
 	 localparam init=0,
 					loop=1;
 					
 	 reg state_q,state_d;
 	 reg signed[9:0] temp1_q,temp2_q,temp3_q;
 	 reg[10:0] pixel_counter_q=1920;
 	 reg first_line,second_line,third_line;
 	 reg we_1,we_2,we_3,we_4,we_5,we_6;
 	 reg signed[8:0] din_ram_x,din_ram_y;
 	 reg[9:0] addr_a_x,addr_a_y,addr_b_q,addr_b_d;
 	 reg write;
 	 reg signed[8:0] data_write;
 	 reg signed[7:0] x,y;
 	 
 	 wire temp_valid;
 	 wire[12:0] gray;
 	 wire signed[8:0] dout_1,dout_2,dout_3,dout_4,dout_5,dout_6;
 	 //wire data_available= data_count_r_sobel!=10'd0 && data_count_r_sobel!=10'd1 && data_count_r_sobel!=10'd2 && data_count_r_sobel!=10'd3 && data_count_r_sobel!=10'd4 && data_count_r_sobel!=10'd5;
 	 wire data_available=data_count_r_sobel>512;
 	 assign rd_en=data_available;
 	 assign rd_fifo_cam=data_available;
 	 //register operation
 	 always @(posedge clk_w,negedge rst_n) begin
 		if(!rst_n) begin
 			temp1_q<=0;
 			temp2_q<=0;
 			temp3_q<=0;
 			state_q<=0;
 			pixel_counter_q<=1920;
 			addr_b_q<=0;
 		end
 		else begin
 			state_q<=state_d;
 			addr_b_q<=addr_b_d;
 			if(data_available) begin //grouping every three pixels for the kernel convolution
 				temp1_q<={3'b000,gray[7:3]};
 				temp2_q<=temp1_q;
 				temp3_q<=temp2_q;
 				pixel_counter_q<=(pixel_counter_q==1919 || pixel_counter_q==1920)? 0:pixel_counter_q+1'b1; //3 lines of pixel(640*3=1920)
 			end
 		end
 	 end
 	 
 	 //assign gray=(din[15:11]+(din[10:5]>>1)+din[4:0])/3; //RGB to grayscale conversion using averaging method
 	 wire[7:0] red,green,blue;
 	 assign red={din[15:11],3'b000},
 				green={din[10:5],2'b00},
 				blue={din[4:0],3'b000};
 	 
 	 assign gray=(red>>2)+(red>>5)+(red>>6) + (green>>1)+(green>>4)+(green>>5) + (blue>>3); 
 	 
 	 //Convolution pipeline logic
 	//data will be stored in block ram(which will be retrieved later by asyn_fifo)
 	 always @* begin
 		we_1=0;
 		we_2=0;
 		we_3=0;
 		we_4=0;
 		we_5=0;
 		we_6=0;
 		
 		din_ram_x=0; 
 		addr_a_x=0;
 		din_ram_y=0;
 		addr_a_y=0;
 		
 		if(pixel_counter_q!=1920) begin //data is now ready for convolution
 			if(first_line) begin //convolution for the first row of the 3x3 kernel
 				we_1=1;
 				addr_a_y= pixel_counter_q;
 				we_4=1;
 				addr_a_x = pixel_counter_q;
 			end
 			
 			else if(second_line) begin //convolution for the second row of the 3x3 kernel
 				we_2=1;
 				addr_a_y= pixel_counter_q-640;
 				we_5=1;
 				addr_a_x = pixel_counter_q-640;
 			end
 			
 			else if(third_line) begin //convolution for the third row of the 3x3 kernel
 				we_3=1;
 				addr_a_y= pixel_counter_q-1280;
 				we_6=1;
 				addr_a_x = pixel_counter_q-1280;
 			end
 			din_ram_y= temp1_q + temp2_q + temp3_q; //Y kernel
 			din_ram_x = -temp3_q + temp1_q; //X kernel
 		end
 		
 	 end
 	 
 	 //Finalize convolution by combining both kernels then store the result in asyn_fifo
 	 always @* begin
 		write=0;
 		data_write=0;
 		x=0;
 		y=0;
 		addr_b_d=addr_b_q;
 		state_d=state_q;
 		
 		case(state_q)
 			init: if(pixel_counter_q==0 && data_available) begin //no data yet
 						addr_b_d=0;
 						state_d=loop;			
 					end
 			loop: if(data_available) begin
 						addr_b_d=pixel_counter_q;
 						if(first_line) begin
 							addr_b_d=addr_b_d;
 							y=dout_1-dout_2; //convolution result for y kernel
 						end
 						else if(second_line) begin
 							addr_b_d=addr_b_d-640;
 							y=dout_2-dout_3; //convolution result for y kernel
 						end
 						else if(third_line) begin
 							addr_b_d=addr_b_d-1280;
 							y=dout_3-dout_1; //convolution result for y kernel
 						end
 						
 						x= dout_4 + dout_5 + dout_6; //convolution result for x kernel
 						write=1;
 						if(x[7]) x=~x; //get absolute value of x since convolution result CAN BE NEGATIVE
 						if(y[7]) y=~y; //get absolute value of y since convolution result CAN BE NEGATIVE 
 						data_write=x+y; //just take the sum since getting the quadratic sum will make this unnecessarily complicated(BUT QUADRATIC SUM IS THE CORRECT WAY)
 						data_write[8]=din[16];
 						//data_write={din[16],gray[7:0]};
 					end
 		default: state_d=init;
 		endcase 
 	 end
 	 
 	 
 	 
 	 always @* begin //determines which pixel line the next data will be stored
 		first_line=0;
 		second_line=0; 
 		third_line=0;
 		if(pixel_counter_q<=639) first_line=1;
 		else if(pixel_counter_q<=1279) second_line=1;
 		else if(pixel_counter_q<=1919) third_line=1;
 	 
 	 end
endmodule
//---- Top entity
module v71739f (
 input vf6ac69,
 input ve163d2,
 input va43ab9,
 input [8:0] vfe854d,
 input [9:0] vf3d037,
 input [9:0] v7583c7,
 output [8:0] vb08192
);
 wire w0;
 wire w1;
 wire w2;
 wire [0:9] w3;
 wire [0:9] w4;
 wire [0:8] w5;
 wire [0:8] w6;
 assign w0 = vf6ac69;
 assign w1 = ve163d2;
 assign w2 = va43ab9;
 assign w3 = vf3d037;
 assign w4 = v7583c7;
 assign w5 = vfe854d;
 assign vb08192 = w6;
 v71739f_v21516f v21516f (
  .clk_r(w0),
  .clk_w(w1),
  .we(w2),
  .addr_a(w3),
  .addr_b(w4),
  .din(w5),
  .dout(w6)
 );
endmodule

//---------------------------------------------------
//-- dual_port_ram
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- uses block ram with separate read/write clock
//---------------------------------------------------

module v71739f_v21516f (
 input clk_r,
 input clk_w,
 input we,
 input [8:0] din,
 input [9:0] addr_a,
 input [9:0] addr_b,
 output [8:0] dout
);
 	localparam ADDR_WIDTH=10,
 	               DATA_WIDTH=9;
 	
 	reg[DATA_WIDTH-1:0] ram[2**ADDR_WIDTH-1:0];
 	reg[ADDR_WIDTH-1:0] addr_b_q;
 	
 	always @(posedge clk_w) begin
 		if(we) ram[addr_a]<=din;
 	end
 	always @(posedge clk_r) begin
 		addr_b_q<=addr_b;	
 	end
 	assign dout=ram[addr_b_q];
endmodule
//---- Top entity
module v1932d4 (
 input v154578,
 input vc312eb,
 input v14fb5c,
 input vbecff9,
 input v88873d,
 input [8:0] v2720e8,
 output v9fff91,
 output v01607e,
 output [10:0] v8ceb21,
 output [10:0] vffb9ca,
 output [8:0] vfba775
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire [0:10] w10;
 wire [0:10] w11;
 wire [0:8] w12;
 wire [0:8] w13;
 wire [0:10] w14;
 wire [0:10] w15;
 assign w1 = v154578;
 assign w2 = vc312eb;
 assign w3 = v14fb5c;
 assign w4 = vbecff9;
 assign w5 = v88873d;
 assign w6 = vc312eb;
 assign w7 = v14fb5c;
 assign v9fff91 = w8;
 assign v01607e = w9;
 assign v8ceb21 = w10;
 assign vffb9ca = w11;
 assign w12 = v2720e8;
 assign vfba775 = w13;
 assign w6 = w2;
 assign w7 = w3;
 v9da8cd v95f545 (
  .va43ab9(w0),
  .ve163d2(w6),
  .vf6ac69(w7),
  .vfe854d(w12),
  .vb08192(w13),
  .vecf018(w14),
  .v050b8b(w15)
 );
 v1932d4_v65c4d4 v65c4d4 (
  .we(w0),
  .rst_n(w1),
  .clk_write(w2),
  .clk_read(w3),
  .write(w4),
  .read(w5),
  .full(w8),
  .empty(w9),
  .data_count_w(w10),
  .data_count_r(w11),
  .w_ptr(w14),
  .r_ptr(w15)
 );
endmodule

//---------------------------------------------------
//-- asyn_fifo
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- fifo with different read/write clock domains
//---------------------------------------------------

module v1932d4_v65c4d4 (
 input rst_n,
 input clk_write,
 input clk_read,
 input write,
 input read,
 output full,
 output empty,
 output [10:0] data_count_w,
 output [10:0] data_count_r,
 output we,
 output [10:0] w_ptr,
 output [10:0] r_ptr
);
  	 localparam DATA_WIDTH=9,
 	            FIFO_DEPTH_WIDTH=11,
 	            FIFO_DEPTH=2**FIFO_DEPTH_WIDTH;
 	 
 	 initial begin
 		full=0;
 		empty=1;
 	 end
 	 
 	 reg full, empty;
 	 reg[10:0] data_count_r,data_count_w;
 	 
 	 ///////////////////WRITE CLOCK DOMAIN//////////////////////////////
 	 reg[FIFO_DEPTH_WIDTH:0] w_ptr_q=0; //binary counter for write pointer
 	 reg[FIFO_DEPTH_WIDTH:0] r_ptr_sync; //binary pointer for read pointer sync to write clk
 	 wire[FIFO_DEPTH_WIDTH:0] w_grey,w_grey_nxt; //grey counter for write pointer
 	 reg[FIFO_DEPTH_WIDTH:0] r_grey_sync; //grey counter for the read pointer synchronized to write clock
 	 
 	 reg[3:0] i; //log_2(FIFO_DEPTH_WIDTH)
 	 
 	 assign w_grey=w_ptr_q^(w_ptr_q>>1); //binary to grey code conversion for current write pointer
 	 assign w_grey_nxt=(w_ptr_q+1'b1)^((w_ptr_q+1'b1)>>1);  //next grey code
 	 assign we= write && !full; 
 	 
 	 //register operation
 	 always @(posedge clk_write,negedge rst_n) begin
 		if(!rst_n) begin
 			w_ptr_q<=0;
 			full<=0;
 		end
 		else begin
 			if(write && !full) begin //write condition
 				w_ptr_q<=w_ptr_q+1'b1; 
 				full <= w_grey_nxt == {~r_grey_sync[FIFO_DEPTH_WIDTH:FIFO_DEPTH_WIDTH-1],r_grey_sync[FIFO_DEPTH_WIDTH-2:0]}; //algorithm for full logic which can be observed on the grey code table
 			end
 			else full <= w_grey == {~r_grey_sync[FIFO_DEPTH_WIDTH:FIFO_DEPTH_WIDTH-1],r_grey_sync[FIFO_DEPTH_WIDTH-2:0]}; 
 			
 			for(i=0;i<=FIFO_DEPTH_WIDTH;i=i+1) r_ptr_sync[i]=^(r_grey_sync>>i); //grey code to binary converter 
 			data_count_w <= (w_ptr_q>=r_ptr_sync)? (w_ptr_q-r_ptr_sync):(FIFO_DEPTH-r_ptr_sync+w_ptr_q); //compares write pointer and sync read pointer to generate data_count
 		end							
 	 end
 
 	/////////////////////////////////////////////////////////////////////
 	 
 	 
 	  ///////////////////READ CLOCK DOMAIN//////////////////////////////
 	 reg[FIFO_DEPTH_WIDTH:0] r_ptr_q=0; //binary counter for read pointer
 	 wire[FIFO_DEPTH_WIDTH:0] r_ptr_d;
 	 reg[FIFO_DEPTH_WIDTH:0] w_ptr_sync; //binary counter for write pointer sync to read clk
 	 reg[FIFO_DEPTH_WIDTH:0] w_grey_sync; //grey counter for the write pointer synchronized to read clock
 	 wire[FIFO_DEPTH_WIDTH:0] r_grey,r_grey_nxt; //grey counter for read pointer 
 	 
 	 
 	 assign r_grey= r_ptr_q^(r_ptr_q>>1);  //binary to grey code conversion
 	 assign r_grey_nxt= (r_ptr_q+1'b1)^((r_ptr_q+1'b1)>>1); //next grey code
 	 assign r_ptr_d= (read && !empty)? r_ptr_q+1'b1:r_ptr_q;
 	 
 	 //register operation
 	 always @(posedge clk_read,negedge rst_n) begin
 		if(!rst_n) begin
 			r_ptr_q<=0;
 			empty<=1;
 		end
 		else begin
 			r_ptr_q<=r_ptr_d;
 			if(read && !empty) empty <= r_grey_nxt==w_grey_sync;//empty condition
 			else empty <= r_grey==w_grey_sync; 
 			
 			for(i=0;i<=FIFO_DEPTH_WIDTH;i=i+1) w_ptr_sync[i]=^(w_grey_sync>>i); //grey code to binary converter
 			data_count_r = (w_ptr_q>=r_ptr_sync)? (w_ptr_q-r_ptr_sync):(FIFO_DEPTH-r_ptr_sync+w_ptr_q); //compares read pointer to sync write pointer to generate data_count
 		end
 	 end
 	 ////////////////////////////////////////////////////////////////////////
 	 
 	 
 	 /////////////////////CLOCK DOMAIN CROSSING//////////////////////////////
 	 reg[FIFO_DEPTH_WIDTH:0] r_grey_sync_temp;
 	 reg[FIFO_DEPTH_WIDTH:0] w_grey_sync_temp;
 	 always @(posedge clk_write) begin //2 D-Flipflops for reduced metastability in clock domain crossing from READ DOMAIN to WRITE DOMAIN
 		r_grey_sync_temp<=r_grey; 
 		r_grey_sync<=r_grey_sync_temp;
 	 end
 	 always @(posedge clk_read) begin //2 D-Flipflops for reduced metastability in clock domain crossing from WRITE DOMAIN to READ DOMAIN
 		w_grey_sync_temp<=w_grey;
 		w_grey_sync<=w_grey_sync_temp;
 	 end
 	 
 	//////////////////////////////////////////////////////////////////////////
 	
 	assign w_ptr=w_ptr_q[10:0];
 	assign r_ptr=r_ptr_d[10:0];
 	 
 	 
 	 
endmodule
//---- Top entity
module v9da8cd (
 input vf6ac69,
 input ve163d2,
 input va43ab9,
 input [8:0] vfe854d,
 input [10:0] vecf018,
 input [10:0] v050b8b,
 output [8:0] vb08192
);
 wire w0;
 wire w1;
 wire w2;
 wire [0:8] w3;
 wire [0:8] w4;
 wire [0:10] w5;
 wire [0:10] w6;
 assign w0 = vf6ac69;
 assign w1 = ve163d2;
 assign w2 = va43ab9;
 assign w3 = vfe854d;
 assign vb08192 = w4;
 assign w5 = vecf018;
 assign w6 = v050b8b;
 v9da8cd_v21516f v21516f (
  .clk_r(w0),
  .clk_w(w1),
  .we(w2),
  .din(w3),
  .dout(w4),
  .addr_a(w5),
  .addr_b(w6)
 );
endmodule

//---------------------------------------------------
//-- dual_port_ram
//-- - - - - - - - - - - - - - - - - - - - - - - - --
//-- uses block ram with separate read/write clock
//---------------------------------------------------

module v9da8cd_v21516f (
 input clk_r,
 input clk_w,
 input we,
 input [8:0] din,
 input [10:0] addr_a,
 input [10:0] addr_b,
 output [8:0] dout
);
 	localparam ADDR_WIDTH=11,
 	               DATA_WIDTH=9;
 	
 	reg[DATA_WIDTH-1:0] ram[2**ADDR_WIDTH-1:0];
 	reg[ADDR_WIDTH-1:0] addr_b_q;
 	
 	always @(posedge clk_w) begin
 		if(we) ram[addr_a]<=din;
 	end
 	always @(posedge clk_r) begin
 		addr_b_q<=addr_b;	
 	end
 	assign dout=ram[addr_b_q];
endmodule
